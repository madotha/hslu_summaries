\documentclass[a4paper]{article}

\usepackage[margin=80pt]{geometry}
\usepackage[ngerman]{babel}

\usepackage[scaled]{helvet}
\renewcommand{\familydefault}{\sfdefault}
\usepackage[T1]{fontenc}

\usepackage[hidelinks]{hyperref}
\hypersetup{colorlinks=false}

\usepackage{enumitem}
\setlist{nosep}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{enumitem}

\usepackage [autostyle]{csquotes}
\MakeOuterQuote{"}

% Package und Einstellungen für Java-Code-Darstellung
\usepackage{listings}
\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{frame=tb,
	language=Java,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3
}

\title{\textbf{SWDE - Software Development\\
Zusammenfassung FS 2019}}
\date{\today}
\author{Maurin D. Thalmann}

\begin{document}
	\pagenumbering{gobble}
	\maketitle
	\newpage
	\pagenumbering{arabic}
	\tableofcontents
	\newpage
	
	\section{Buildautomatisation}
	
		\subsection{Sie kennen die Vorteile eines automatisierten Buildprozesses}
			\begin{itemize}
				\item Automatisierter Ablauf, keine Interaktion mehr benötigt
				\item Reproduzierbare Ergebnisse
				\item lange Builds können auch über Nacht laufen
				\item Unabhängig von Entwicklungsumgebung
			\end{itemize}
		
		\subsection{Sie können verschiedene Beispiele von Buildwerkzeugen benennen}
			\begin{description}
				\item[Make] (für C/C++ Projekte), Urvater der Build Tools, \\
				hohe Flexibilität, gewöhnungsbedürftige Syntax
				\item[Ant] Java mit XML
				\item[Maven] Java mit XML
				\item[Buildr] Ruby-Script
				\item[Gradle] Groovy Script mit DSL
				\item[Bazel] Java mit Python-like Scripts
			\end{description}
		
		\subsection{Sie beherrschen die Anwendung eines ausgewählten Buildwerkzeuges (Apache Maven)}
		Beherrschen muss man es selber, es kann entweder aus der Shell (Terminal/Konsole) verwendet werden oder aus den integrierten Funktionen in der IDE selbst.
		
		\subsection{Sie sind mit den wesentlichen Konzepten von Apache Maven vertraut}
		Deklaration des Projektes in XML, zentrales Element pro Projekt ist das \textbf{Project Object Model (POM)}, welches Metainformationen, Plugins und Dependencies definiert. 
		Basiert auf einem globalen, binären Repository. Plugins werden durch Dependencies dynamisch ins lokale Repository geladen (\$HOME/.m2/repository)\\
		Bei einem Buildprozess durchläuft ein Projekt einen Lifecycle mit folgenden Phasen:\\
		\begin{description}
			\item[validate] validiert Projektdefinition
			\item[compile] Kompiliert die Quellen
			\item[test] Ausführen der Unit-Tests
			\item[package] Packen der Distribution
			\item[verify] Ausführen der Integrations-Tests
			\item[install] Deployment im lokalen Repository
			\item[deploy] Deployment im zentralen Repository
		\end{description}

	\newpage
	\section{Modularisierung - Module, Komponenten, Schnittstellen}
	
	\subsection{Sie wissen, was unter dem Begriff Modularisierung zu verstehen ist}
	\textit{«Ein grosses Ganzes in mehrere, sich abgeschlossene Einheiten (Module) aufteilen»} \\
	Flexible Zusammenstellung, Durchführung und Prüfung der einzelnen Module. 
	Zwischen den Modulen können aber auch Abhängigkeiten bestehen.
	
	\subsection{Sie kennen die Begriffe Modul, Library, Komponenten und Schnittstelle auf der Ebene des Softwaredesigns}
	\textbf{Kleinste Einheit:} Klasse (Methoden/Daten/Attribute) $\leftrightarrow$ \textbf{Grösste Einheit:} vollständiges Softwaresystem
	\begin{description}
		\item[Modul] In sich abgeschlossene und austauschbare Einheiten, \\
		soll nur über seine Schnittstellen verwendet werden können $\rightarrow$ lose Kopplung; \\
		Starke Kohäsion (möglichst in sich abgeschlossene Aufgabe erfüllen) $\rightarrow$ Information Hiding
		\item[Schnittstelle] lässt Module untereinander interagieren / austauschen
		\item[Komponente] strengere Form eines Moduls
		\item[Library] Eine Sammlung thematisch zusammengehörender Funktionen (z.Bsp. Kalendermodul, Trigonometriemodul, etc.)
	\end{description}
	\textit{Die einzelnen Begriffe werden in einem späteren Lernziel ausführlicher beschrieben.}
	
	\subsection{Sie können die Begriffe auf verschiedenen Abstraktionsebenen in einen sinnvollen Zusammenhang und Kontext setzen}
	\begin{description}
		\item[Kopplung] Ausmass der Kommunikation zwischen Modulen (Abhängigkeit zw. Modulen)
		\item[Kohäsion] Ausmass der Kommunikation innerhalb eines Moduls (interner Zusammenhalt)
		\item[Ziel] $\rightarrow$ Maximierung der Kohäsion, Minimierung der Kopplung
	\end{description}
	\begin{description}
		\item[Gruppierung] Modulen mit gemeinsamen Eigenschaften als Gruppe handhaben. \\
			\textit{Beispiel}: Modul für Datenexport in versch. Formate
		\item[Hierarchie (Rekursiv)] Modul fasst mehrere (Sub-) Module zu einem zusammen. \\
			\textit{Beispiel}: Persistenzmodul als Datenspeicher mehrerer Entitäten
		\item[Geschichtet] Modul(-gruppen) können logische Kette bilden, die vertikal als Schichten abgebildet werden. \\
			\textit{Beispiel}: Schichtenarchitektur, OSI-Referenzmodell, etc.
	\end{description}
	
	\newpage
	\subsection{Sie sind in der Lage ein System zu analysieren und darin sinnvolle Module zu identifizieren}
	
	\subsubsection{Modul}
	\textbf{\underline{Kriterien für Entwurf von Modulen:}}\\
	\textbf{Zerlegbarkeit / Dekomposition}\\
	möglichst unabhängig voneinander, können einzeln genutzt/wiederverwendet werden\\
	\textbf{Kombinierbarkeit}\\
	sollen in anderem Umfeld wieder einsetzbar sein \\
	\textit{(Zerlegbar, um auf andere Art wieder kombiniert werden zu können)}\\
	\textbf{Verständlichkeit}\\
	unabhängig und in sich abgeschlossen verständlich sein, kann aber trotzdem hohe Komplexität erreichen.\\
	\textbf{Stetigkeit / Stabilität / Kontinuität}\\
	Struktur soll sich nicht stetig verändern, Aufteilung soll robust gegenüber Änderungen sein. Änderungen sollen sich auf eine minimale Anzahl Module beschränken.\\
	\newline
	\textbf{\underline{Arten von Modulen:}}\\
	\textbf{Bibliothek/Library:} beschrieben unter Kapitel 2.2\\
	\textbf{Abstrakte (komplexe) Datentypen:} Modul implementiert neuen komplexen Datentyp und stellt darauf definierte Operationen zur Verfügung (Bsp. Komplexe Zahlen, Koordinatendarstellung, etc.)\\
	\textbf{Modellierung/Abstraktion physischer Modelle:} Modul abstrahiert reales, physisch existierendes System (z.Bsp. Sensor, Gerätetreiber, Anzeigemodul, etc.)\\
	\textbf{Modellierung/Abstraktion logisch-konzeptioneller Systeme:} Modul abstrahiert ein nur rein logisch existierendes System und macht es für eine höhere Abstraktionsebene nutzbar (z.Bsp. Grafikmodule, Datenbankmodule, Messaging, GUI-Module, etc.)\\
	\newline
	\textbf{\underline{Definition eines Moduls:}}\\
	\textbf{Verhalten:} Funktionalität des Moduls?\\
	\textbf{Export:} Was bieten wir, Schnittstelle, um das Verhalten des Moduls für andere Module verfügbar zu machen.\\
	\textbf{Import:} Was brauchen wir, von welchen Schnittstellen ist das Modul evtl. abhängig? (Dependencies)\\
	\newline
	\textbf{\underline{Herausforderung bei Modulen:}} \\
	\textbf{Basiskonzepte:} Hohe Kohäsion, lose Kopplung, starke Datenkapselung \& Information Hiding\\
	\textbf{Vier Kriterien:} Zerlegbarkeit, Kombinierbarkeit, Verständlichkeit \& Stetigkeit\\
	\textbf{Verschiedene Arten:} Bibliotheken, abstrakte Datentypen, physische / logische Modelle, Komponenten, etc.

	\subsubsection{Komponente}
	\begin{quote}
		\textit{Eine Softwarekomponente ist ein Softwareelement, das zu einem
bestimmten \textbf{Komponentenmodell} passt und entsprechend
einem Composition Standard ohne Änderungen mit anderen
Komponenten verknüpft und ausgeführt werden kann.}
	\end{quote}
	Eine \textbf{Komponente} erfüllt strengere Kriterien als ein Modul und benötigt meist einen \textbf{Kontext}.
	Komponenten bedienen sich spezifischer Laufzeitumgebungen (z.Bsp. Container) in welche die Komponenten integriert (installiert, deployed, etc.) werden und dort lauffähig sind (Container stellen den Komponenten Basisdienste z.Bsp. für Lifecycle und Kommunikation bereit)\\
	Komponenten können teilweise \textbf{dynamisch zur Laufzeit} ergänzt/entfernt/ausgetauscht werden
	\\ \indent $\rightarrow$ «Hot-Deployment» / Plugin-Mechanismen\\
	Komponenten bieten Funktionalität an und sind von Funktionalität des eingesetzten Komponentenmodells (Framework/Produkt) \textbf{abhängig}.\\
	
	\newpage
	\noindent
	\textbf{Komponentenmodelle}: konkrete Ausprägungen des Paradigmas der komponentenbasierten Entwicklung in Form eines Standards, Frameworks, Produktes. Schnittstellen für Interaktion und Komposition von Komponenten festlegen: wie kommunizieren Komponenten untereinander/mit dem Container Idealerweise: Komponentenmodell unabhängig von Gremium standardisiert (kann somit in unterschiedlichen Ausprägungen von versch. Herstellern implementiert/genutzt werden)
	\begin{quote}
			\textbf{Beispiele}: Microsoft DCOM/ActiveX/.NET Remoting Services (WCF), CORBA (Common Object Request Broker Architecture), Enterprise Java Beans, OSGi (Open Services Gateway initiative / Alliance)
	\end{quote}
	\textbf{Komponente} wird wie Modul über \textit{Verhalten, Export, Import} definiert. \\
	Zusätzlich wird ein \textbf{Kontext} verlangt: definiert notwendige Rahmenbedingungen, die für Betrieb der Komponente notwendig sind.
	
	\subsubsection{Schnittstelle}
	Schnittstellen werden konsequent für die kontrollierte Kommunikation zwischen Modulen oder Komponenten verwendet. \textbf{Vorteile} davon:
	\begin{itemize}
		\setlength\itemsep{0em}
		\item Schnittstelle ist einfach verständlich, einfacher als die Implementierung.
		\item Schnittstellen helfen Abhängigkeiten zu reduzieren, vermeiden Abhängigkeiten zur Implementierung.
		\item Schnittstellen erleichtern Wiederverwendung.
	\end{itemize}
	Beziehungen zwischen einzelnen Teilen einer Software werden über Schnittstellen realisiert. Module konzentrieren sich auf ihre lokalen Probleme, Architektur definiert und hält Fäden (Beziehungen) des Systems zusammen.\\
	Schnittstellen sollen minimal und schmal sein $\rightarrow$ aussagekräftige Methoden, präzis typisierte Parameter, \textbf{Methoden} sollen möglichst:
	\begin{itemize}
		\setlength\itemsep{0em}
		\item keine Überschneidungen haben
		\item keine globalen Daten verwenden
		\item statuslos (stateless) sein
	\end{itemize}
	\textbf{Service}: abstrahierte Schnittstelle, definiert sich primär über Fachlichkeit, dahinterliegende Technik idealerweise vollständig isoliert (Bsp. Webservice, wird über Web-Protokolle angeboten und abstrahiert die Implementation [Plattform, Sprache, Technologie] vollständig) \\
	\textbf{API}: \textit{(Application Programming Interface)}, technisch orientierte Schnittstelle, welche die Anbindung einer Komponente auf Quellcodeebene definiert (Bsp. JDBC [Java Database Connectivity], einheitliche Schnittstelle zur Kommunikation mit versch. DBMS) \\
	Ebene \textbf{Objektorientiertes Design}: Schnittstelle = Java Interface \\
	Ebene \textbf{Modularisierung}: Schnittstelle = logische Zusammenfassung versch. Artefakte (Klassen, Interfaces, Konfigurationsdateien, Doku etc.)
	
	\newpage
	\subsection{Sie kennen verschiedene organisatorische und technische Varianten um eine sinnvolle Modularisierung in der Entwicklung und im Deployment einzusetzen}
	\subsubsection{Java 8}
	Module/Komponenten mit Klassen und Interfaces realisiert, Deployment meist als JAR. 
	Klassen können sich an «Java Bean Spezifikation» halten \\ 
	\indent $\rightarrow$ Default-Konstruktor, Setter/Getter, PropertyChange, Serialisierbar, etc. \\
	Schnittstellen mit Java-Interfaces (zu class-Dateien kompiliert) \\
	Komplexere Schnittstellen: mehrere Interfaces in Package zusammenfassen \\
	Java 1.8 unterstützt selber keine Modularisierung \\
	Information Hiding (einzelne Elemente vor Zugriff schützen) durch Packages, Sichtbarkeiten und Import, ermöglicht Zusammenfassen von Klassen/Interfaces in Gruppen, aber keine explizite Möglichkeit, Exports \& Dependencies zu deklarieren \\
	manifest.mf enthält Infos zu Identifikation, Herkunft und Version \\
	Schnittstellen in getrennten JAR’s (Modulen) verteilen $\rightarrow$ einfacher Austausch unterschiedlicher Implementationen \\
	\textit{Workaround}: Namenskonventionen und hohe Disziplin \\
	
	\subsubsection{Java 9}
	Modularisierung möglich, drei Ziele im Vordergrund:
	\begin{itemize}
		\setlength\itemsep{0em}
		\item \textbf{Reliable Configuration:} \\
		fehleranfälligen Classpath durch auf Modul-Abhängigkeiten basierenden Modul-Path ablösen
		\item \textbf{Strong Encapsulation:} \\
		Modul definiert explizit sein öffentliches API. 
		Auf alle restlichen Klassen ist von aussen kein Zugriff mehr möglich (auch wenn public).
		\item \textbf{Scalable Platform:} \\
		Java-Plattform selber wurde modularisiert, so können für Anwendungen individuell angepasste, schlankere Runtime-Images gebaut werden.
	\end{itemize}
	Weiteres zu Modularisierung in Java 9:
	\begin{itemize}
		\setlength\itemsep{0em}
		\item Java-Packages neu in Modulen zusammenfassbar (zusätzliche Strukturebene in der Dateiablage, eindeutige Namensgebung analog zu Packages)
		\item Pro Modul wird ein \textit{module-info.java} definiert (explizite Definition von Imports/Exports/Abhängigkeiten)
		\item Start einer Applikation: Laufzeitprüfung wird ausgeführt, ob alle notwendigen Komponenten vorhanden sind.
		\item Ende der «JAR-Hell»: Neues Format \textit{jmod}, Class-Path wird durch Modul-Path abgelöst
		\item Vollständig rückwärtskompatibel
	\end{itemize}

\newpage
\section{Dependency Management}

	\subsection{Sie haben ein grundsätzliches Verständnis von Dependency Management}
	
	\paragraph{Dependency Management}
	
	Beschreibt die Organisation und Techniken für Umgang mit Abhängigkeiten mi anderen Modulen.\\
	\textit{("Modul" hier vereinfacht als Überbegriff für Package / Library / Bundle / Komponente verwendet)}\\
	Abhängigkeiten können auf \textbf{interne} (Modul aus demselben Projekt) oder \textbf{externe} (Dritt-Modul aus anderem Projekt / Organisation) Module bestehen.
	Abhängigkeiten werden typisch in binärer / kompilierter Form aufgelöst, wozu Binärrepositories und Packagemanager(-tools) eingesetz werden.\\
	Allen Systemen / Repositories ist gemeinsam:
	\begin{itemize}
		\item Zentrale Ablage auf einem (oder mehrere) Server
		\item standartisiertes Format
		\item zusätzliche Metainformationen
		\item typisch mit Abhängigkeiten (Dependencies) versehen
		\item Sicherung der Konsistenz (bspw. über Hash-Mechanismen)
		\item geregelte Zugriffsprotokolle
		\item Suchmöglichkeiten u.v.m.
	\end{itemize}
	\vspace{1em}
	Beispiele von populären Systemen / Repositories für DM und PM:
	\begin{description}
		\item[NuGet] Package Manager für .NET-Plattform
		\item[apt] Advanced Packaging Tool - Packetverwaltung für Linux
		\item[Yum] Yellowdog Updater, Modified - Packetverwaltung für Linux
		\item[P2] OSGi-basiertes Komponentensystem
		\item[npm] Node Packet Manager für JavaScript / node.js
		\item[Gems] Packetmanager Ruby
	\end{description}
	
		\subsubsection{Maven Repository}
		
		\begin{itemize}
			\item Verschiedene öffentliche Repos \textbf{(OSS)}: Maven Central, JFrog JCenter (BinTray)
			\item Keine Schreibrechte auf öffentliche Repos (nur ausgewählte Personen über definierte Prozesse)
			\item Professionelle Organisationen betreiben interne Repositories, meist als lokaler Speicher und Mirror von öffentlichen Repos, professionelle Produkte wären:\\ 
			\textit{Apache Archiva, JFrog/Artifactory, Sonatype/Nexus}
			\item Alle heruntergeladenen Artefakte vom Repo werden in lokalem Repo auf dem Rechner gespeichert (Caching) unter \texttt{\$HOME/.m2/repository}
			\item Zur Verwendung muss unter \texttt{\$HOME/.m2} die \texttt{settings.xml} Datei angepasst werden, damit die Dependencies nicht vom öffentlichen Repo geholt werden
		\end{itemize}

\newpage
	
	\subsection{Sie wissen wie am Beispiel von Java und Apache Maven das Dependency Management funktioniert}
	
	\begin{itemize}
		\item Binäre Module (kompilierte Projekte) werden unter Java typischerweise als JAR-Dateien ausgetauscht (oder EAR, WAR, RAR etc.)
		
		\item Java kennt selber kein Verfahren zur Defintion von Abhängigkeiten zwischen Modulen und deren zentraler Verwaltung\\
		(Ab Java 9: Modularisierung (Jigsaw), aber ohne Versionierung)
		
		\item Früher: JAR-Dateien von Hand in Projekte kopiert \\
		$\rightarrow$ fehleranfällig, hohe Redundanz, hoher Platzbedarf etc.\\
		Heute ist Buildsystem Maven sehr populär geworden
		
		\item Unterscheiden zwischen:
		\begin{itemize}
			\item \textbf{Format} für die zentrale Ablage der meist binären Artefakten mit Metainformationen im Repository
			\item \textbf{Werkzeug}, um Artefakte von Repos zu suchen, beziehen, deployen, ggf. auch verwalten
		\end{itemize}
	
		\item Repositoryformat Maven mittlerweile Standard, jedoch grosse Vielfalt bei Werkzeugen:
		\begin{itemize}
			\item Apache Ivy - einziges "reines" DM-Tool
			\item Apache Maven - in Buildtool integriert, Original
			\item DM anderer Buildtools basiert ebenfalls auf Maven-Repos:\\
				Buildr, Groovy Grape, Gradle/Grails, SBT etc. 
		\end{itemize}
	\end{itemize}

		\subsubsection{Maven - Identifikation \& Dependencies}
		
		Maven Projekt identifiziert sich mit drei Attributen (\textbf{maven coordinates})
		\begin{itemize}
			\item \textbf{GroupId}:\\
					Reverse Domain Name der Organisation mit Zusatz für OE bspw. Projektgruppe\\
					Bsp: \texttt{ch.hslu.swde}
					
			\item \textbf{ArtifactId}:\\
					Name des Projekts bzw. enthaltene Module\\
					Bsp: \texttt{vereinsverwaltung-service}
					
			\item \textbf{Version}:\\
					Empfohlen: dreistellige Versionsnummer (Semantic Versioning)\\
					Bsp: \texttt{4.0.1}
		\end{itemize}
	Diese werden im \texttt{pom.xml} des Maven Projekts deklariert, damit soll eine Dependency weltweit absolut eindeutig identifiziert werden können:
	\begin{lstlisting}
<groupId>ch.hslu.swde</groupId>
<artifactId>vereinverwaltung-api</artifactId>
<version>4.0.1</version>
	\end{lstlisting}
	\noindent
	Benötigte Dependencies werden im \texttt{pom.xml} unter \texttt{<dependencies>} als ein \texttt{<dependency>}-Element eingetragen. 
	Diese werden beim Build automatisch vom Repo runtergeladen und im lokalen Repository (\texttt{\$HOME/.m2/repository}) gespeichert.
	Der Buildprozess referenziert die Artefakte dort mit entsprechendem Classpath:
	\begin{lstlisting}
<dependency>
	<groupId>ch.hslu.swde</groupId>
	<artifactId>vereinverwaltung-api</artifactId>
	<version>4.0.0</version>
	<scope>compile</scope>
</dependency>
	\end{lstlisting}
	
	\newpage
	
	\subsection{Sie sind mit den Begriffen «dependency scopes» und «transitive dependencies» vertraut und können diese erklären}
	
		\subsubsection{Dependency Scopes}
		
		\texttt{<scope>} in einer Dependency qualifiziert den Zweck und Geltungsbereich einer Dependency (wird empfohlen). 
		Abhängig von Scopes sorgt Maven für spezifische Classpaths, woraus sich eine \textit{implizite Verifikation des Designs} ergibt. 
		Maven kennt viele Scopes, die Wichtigsten sind:
		\begin{itemize}
			\item \textbf{compile}\\
					(Default) Dependency wird für Kompilation und Laufzeit des Programms benötigt
					
			\item \textbf{test}\\
					Dependency nur für Kompilation und Ausführung der Testfälle benötigt (JUnit, AssertJ, Mockito)
					
			\item \textbf{runtime}\\
					Dependency nur für Laufzeit, aber nicht für Kompilation, \\
					bspw. für dynamisch geladene Implementationen
			
		\end{itemize}
		
		\subsubsection{Transitive Dependencies}
		
		Maven bietet Feature zur Auflösung von transitiven Dependencies.
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[keepaspectratio, height=1cm]{img/dependencymanagement/transitive_dependencies.png}
			\caption{Transitive Abhängigkeit zwischen 3 Modulen}
			\label{fig:transitive}
		\end{figure}
	
		Auflösung der Dependencies:
		\begin{itemize}
			\item \textbf{Modul A} ist von \textbf{Modul B} abhängig, dieses wiederum von \textbf{Modul C}
			\item \textbf{Modul A} ist also transitiv auch von \textbf{Modul C} abhängig
			\item Für Kompilation wird also \textbf{Model C} auch benötigt\\
			
			\item Durch direkte \& transitive Abhängigkeiten können auch Konflikte oder Zyklen auftreten.\\
			Maven erkennt und meldet diese, einfachere Konflikte können automatisch aufgelöst werden.
			\item Maven wertet die Dependencies als Graph aus, dient der Suche von Zyklen und Auflösung von Konflikten z.Bsp. über den kürzesten Pfad.
		\end{itemize}
	
	\subsection{Sie kennen das Versionskonzept und die Funktionsweise von Snapshots.}
	
	\begin{itemize}
		\item Einsatz von \textit{Semantic Versioning} wird empfohlen
		\item Einmal deployte Version kann im Optimalfall nicht mehr überschrieben werden\\
				$\rightarrow$ nachvollziehbare Buildprozesse
	\end{itemize}

			\paragraph{Semantic Versioning}
			
			\begin{itemize}
				\item \textbf{Major}-Release (\textbf{X}.x.x)\\
						Veränderungen in API, fachlicher Funktion und/oder in Konfiguration, welche zu früheren Versionen nicht kompatibel sind.
						Meist sind Anpassungen notwendig.
						
				\item \textbf{Minor}-Release (x.\textbf{X}.x)\\
						Erweiterungen in API, fachlicher Funktion oder Konfiguration, ist aber rückwärtskompatibel.
						Ohne Nutzung der Neuerungen keine Anpassungen notwendig.
						
				\item \textbf{Bugfix/Maintenance}-Release (x.x.\textbf{X})\\
						Reine Korrekturen in Änderungen oder Implementation, voll rückwärtskompatibel, keine neuen oder veränderten Funktionen.
						Direkter, sofortiger Einsatz möglich/notwendig (Bugfix)
			\end{itemize}
		
			\paragraph{Versionierung mit Snapshots}
			
			\begin{itemize}
				\item Version kann das Appendix \texttt{-SNAPSHOT} tragen.
				\item Gilt dann als erneuerbar und noch nicht stabil, sondern in Entwicklung
				\item Wird bei jedem \textbf{Build} vom Repo aufgelöst und aktualisiert
				\item Im Repo sind Snapshots mit Timestamp versehen
			\end{itemize}
	
		\subsubsection{Managed Dependencies in Multi-Modul-Projekten}
		
		\begin{itemize}
			\item Mehrere Submodule können von gleicher Dependency abhängig sein
			\item In jedem Modul sollte dieselbe Version verwendet werden
			\item \textbf{Lösung:} Im Master-POM über \texttt{dependencyManagement}-Element eine Liste an Dependencies (inkl. Version und Scope) als Baseline / Valid Version Set vordefinieren\\
			$\rightarrow$ Submodule müssen nur noch GroupId und ArtifactId angeben.
			Version und Scope werden vom Parent-POM vererbt.
			\item \textbf{\textit{Alternativ:}} Verwendung eines BOM (Bill of Material):\\
			Verschiedene Versionen werden in "virtueller" Release-Unit als "Baseline" referenziert.
			Lieferant bestimmt, welche zueinander passenden Versionen eingesetzt werden.
			Das BOM wird selber als Dependency definiert.
		\end{itemize}
	
	\subsection{Sie wissen auf welche Art Dependencies deployed werden}

	\begin{itemize}
		\item Häufigste Deployment-Art: JAR-Dateien
		\item Beispiel für ein Artefakt\\
				\texttt{ch.hslu.vsk:stringpersistor-api:4.0.1}:
			\begin{description}
				\item[POM (Metainfos)] \texttt{stringpersistor-api-4.0.1.\textbf{pom}}
				\item[JAR (Binary)] \texttt{stringpersistor-api-4.0.1.\textbf{jar}}
				\item[JavaDoc] \texttt{stringpersistor-api-4.0.1-\textbf{javadoc}.jar}
				\item[Source (bei OSS)] \texttt{stringpersistor-api-4.0.1-\textbf{sources}.jar}\\
			\end{description}
		
		\item Deployment in öffentliche Repos: sehr restriktiv\\
				$\rightarrow$ nichts mehr ändern, nichts löschen: Stabilität von Builds wahren!
		
		\item \textbf{Lösung:} nachvollziehbarer, automatisierter, verifizierbarer Release-Prozess, welcher von einem Build-Server ausgeführt wird
	\end{itemize}
	
	\newpage	
	\section{Versionskontrollsysteme - Source Code Management (SCM) / Version Control Systems (VCS)}
	
		\subsection{Sie kennen die Aufgaben eines Versionskontrollsystems und können grundlegend damit arbeiten}
		\textbf{Grundlegende Arbeit:}
		\begin{description}
			\item[checkout] lokale Arbeitskopie eines Projekts erstellen
			\item[update] Änderungen Dritter in Arbeitskopie aktualisieren
			\item[log] Bearbeitungsgeschichte eines Artefakts ansehen
			\item[diff] verschiedene Revisionen miteinander vergleichen
			\item[commit / checkin] Artefakte ins Repository schreiben $\rightarrow$ aussagekräftiger Kommentar!
		\end{description}
		\textbf{Tagging:} Revisionsstand mit Namen markieren, Marke oder Version: 1.5.2beta o.ä. Nützlich bei Release eines Produkts (aber auch meilensteine, Testversionen, Auslieferungszustände, etc.) wird unterschiedlich realisiert.\\
		\\
		\textbf{Branching:} Parallele, voneinander getrennte Entwicklungszweige (für Bugfixing, Prototypen, Tests, Experimente, nachvollziehbare Änderungsworkflows, etc.) Bei Nicht-Wegwerf-Entwicklungen später Merging möglich/notwendig.\\
		\\
		Ausschliesslich Quell-Artefakte werden verwaltet, \textbf{NIE} generierte/erzeugt Artefakte einchecken, können mit Hilfe der SCM ignoriert werden (.gitignore)
		
		\subsection{Sie kennen die verschiedenen Konzepte und Arten von Versionskontrollsystemen}
		\begin{itemize}
			\item Zentrale oder verteilte Systeme 
			\item Optimistische und pessimistische Lockverfahren 
			\item Versionierung auf Basis einer Datei, Verzeichnisstruktur oder der Änderung (changeset) 
			\item Transaktionsunterstützung (vorhanden oder nicht) 
			\item Verschiedene Zugriffsprotokolle und Sicherheitsmechanismen 
			\item Integration in Webserver (vorhanden oder nicht)
		\end{itemize}
		
		\subsection{Sie können mit verschiedenen (Client-)Werkzeugen von Versionskontrollsystemen alleine und im Team arbeiten}
		
		\begin{description}
			\item[CVS] UT-Versionskontrollsystem, stabil, wenig Fehler, einfache Anwendung, ABER nur dateibasierend, Verzeichnisstruktur nicht versioniert, unterscheidet zwischen Text- und Binärdateien, Ablage von Binärdateien platzintensiv, keine Transaktionen
			\item[Subversion] Transaktionsorieniert, versioniert ganze Verzeichnisstruktur, optimierte/effiziente Speicherung und Übertragung, Repositorystruktur frei wählbar (für Experten flexibler, für Anfänger schwieriger), Integration in Webserver möglich, aber Branching und Tagging technisch eig. Kopien/Links
			\item[git] verteiltes System, primär lokale Arbeit, beliebig viele Server/Repos möglich, auch rein lokal einsetzbar, skaliert, Integration mit zusätzlichen Web-Applikationen, erfordert aber ein solides Konzept, für Einsteiger schwierig, da sehr mächtig und viele Funktionen
		\end{description}
	
	\newpage
	\section{Testing Grundlagen}
		
		\subsection{Sie kennen die Motivation, den Sinn und den Zweck des Testens, was Sie mit Tests erreichen können und was nicht}
		
		\begin{quote}
			\textbf{Qualität} ist die Übereinstimmung mit den Anforderungen unter gleichzeitiger Einhaltung von Qualitätskriterien.
		\end{quote}
		\noindent
		Anforderungen müssen überprüfbar formuliert sein, typisch in Form von System- und Testspezifikationen.
		\textbf{Qualitätskriterien} sind: Funktionalität, Zweckdienlichkeit, Robustheit, Zuverlässigkeit, Sicherheit, Effizienz, Benutzbarkeit, Geschwindigkeit etc.
		Zur Überprüfung von diesen stehen uns Methodiken, Techniken, Vorgehensweisen etc. zur Verfügung.
		
		\begin{itemize}
			\item Wesentliche Tätigkeit ist das Testen - Qualitätssicherung durch Testen
			\item Wir überprüfen Verhalten eines Programms anhand der Spezifikationen
			\item Möglichst oft automatisiert teste, manuelles Testen ist aufwändig und zeitintensiv
			\item Begleitmassnahmen: Reviews, Entwicklungsprozess, Walkthrough, Metriken, Analysen, Regression, Automatisation etc.
		\end{itemize}
		
			\subsubsection{Welche Fehler können wir finden?}
			
			\begin{itemize}
				\item \textbf{Syntaktische Fehler:}\\
						Abweichungen von der Sprachsyntax (Schreibweise \& Grammatik) $\rightarrow$ formale Fehler.\\
						Diese werden durch Compiler aufgedeckt!
						\begin{itemize}
							\item Beispiel Sprache: \textit{"Der Lesr list ein Buck"}
							\item Beispiel Java: \texttt{if(i = 10) then{ i = 0; }}
						\end{itemize}
					
				\item \textbf{Semantische Fehler:}\\
						Abweichungen/Unstimmigkeiten, die auf Kenntnisse über Dinge beruhen $\rightarrow$ inhaltliche Fehler
						\begin{itemize}
							\item Beispiel Sprache: \textit{"Die Erdnuss ass einen Elefanten"}
							\item Beispiel Java: \texttt{double kelvin= celsius-273.15d;}
						\end{itemize}
					
				\item \textbf{Funktionale Fehler:}\\
						Abweichung von Anforderungen oder Erfüllung falscher/unerwünschter Anforderungen.\\
						Funktionale Fehler können \textbf{nur bedingt} durch Testen gefunden werden
						\begin{itemize}
							\item Beispiel: \textit{"Ein Liter Bier kostet ab jetzt 1000.-"}
						\end{itemize}
			\end{itemize}
			\vspace{1em}
			\noindent
			Testen ist systematisches, gezieltes  und möglichst effizientes "Durchprobieren" nach verschiedenen Qualitätskriterien.\\
			\textbf{Systematisch, gezielt} mit wohlüberlegten Eingabedaten / Testwerten\\
			\textbf{Effizient} möglichst aussagekräftige Tests durchführen\\
			Testen ist also \textbf{nicht} zielloses, chaotisches Pröbeln, sondern anspruchsvoller als man denkt.\\
			Man kann nur Vorhandensein von Fehlern, aber nie die Abwesenheit von Fehlern beweisen.
			Nach Test weiss man nur, dass ein Programm für die getesteten Eingabedaten korrekt läuft.\\
			$\rightarrow$ Eingabedaten so wählen, dass auf möglichst viele Varianten von möglichen Eingabedaten rückgeschlossen werden kann. 
			Also auch untypische Daten miteinbeziehen.\\
			Beispiel bei einem Sortieralgorithmus:
			\begin{itemize}
				\item beliebige, zufällige Daten (\textbf{Normalfälle})
				\item vorsortierte Daten, keine Daten (\textbf{Sonderfälle})
				\item ungültige, nicht sortierbare Daten (\textbf{Ausnahmefälle})
			\end{itemize}
			
			\begin{figure}[htb!]
				\centering
				\includegraphics[keepaspectratio, height=3cm]{img/testing/planungstabelle.png}
				\caption{Tabelle für die Planung von Testfällen}
				\label{fig:table_testing}
			\end{figure}
			
			
		
		\subsection{Sie kennen verschiedene grundlegende Testarten und –verfahren}
		
		\begin{itemize}
			\item \textbf{Unit Tests:}\\
				\textit{Nur eine Methode/Klasse/Einheit wird getestet}\\
					Sehr klein, übersichtlich, einfach, schnell ausführbar, einfach automatisierbar \\
					(Ausführung \& Validation)
					
			\item \textbf{Integrationstests:}\\
					\textit{Mehrere Klassen (Module/Teilsysteme) in ihrem Zusammenspiel werden getestet}\\
					Deutlich aufwändiger, aber auch automatisierbar
					
			\item \textbf{Systemtest:}\\
					\textit{Ganzes System (viele Klassen/Einheiten) wird getestet}\\
					Klassisches Testen, erst spät möglich, aufwändig, auch automatisierbar
					
			\item \textbf{Black}- und \textbf{White}-Box Testing:\\
					Testen \textbf{ohne} oder \textbf{mit} Kenntnis der Implementation
			
		\end{itemize}
		
		\subsection{Sie können in Ihrer Entwicklungsumgebung einfache und gute Unit Tests, basierend auf dem JUnit-Framework, implementieren und anwenden}
		
			\subsubsection{Unit Tests}
			
			\begin{itemize}
				\item Testfälle programmiert, somit automatisiert, jederzeit schnell ausführbar und wiederholbar
				\item Sind "self-validating": Automatische Verifizierung, ob Testfall erfolgreich ausgeführt wurde
				\item Getestete Einheiten: einzelne Methoden oder Klassen\\
						$\rightarrow$ Kleine, überschauliche Testfälle
				\item Zahlreiche Frameworks für Testing, sind gut in IDEs integriert\\
						$\rightarrow$ Für Java: JUnit, UnitNG etc.
			\end{itemize}
		
			Nutzen daraus:
			\begin{itemize}
				\item Zeitersparnis: einmal schreiben, n-mal ausführen
				\item Kein manuelles "Testen" mehr
				\item \texttt{System.out.println()}-Orgien entfallen
				\item Jederzeit reproduzierbar
				\item Automatische Verifizierung der Ergebnisse mit Reporting
				\item Testfälle "dokumentieren" erwartete Funktion/Resultat
				\item Freiheit, mit geringem Risiko Code zu verändern / umschreiben (Refactoring)
			\end{itemize}
		
			\subsubsection{JUnit Test Framework}
			
			\begin{itemize}
				\item Aktuelle Version ist JUnit 5
				
				\item JUnit wird heute für alle automatisierbaren Testfälle eingesetzt\\
						$\rightarrow$ \textit{Nicht jeder JUnit-Testfall ist ein Unit-Test!}
						
				\item JUnit 5 hat viele Verbesserungen, ist aber nicht rückwärtskompatibel (OMG ein Major-Release!)
			\end{itemize}
			\noindent
			Ein Testfall entspricht dem "Build-Operate-Check"-Pattern:
			\begin{enumerate}
				\item \textbf{Erstellen} der Testobjekte bzw. -daten
				\item \textbf{Manipulieren} der Testobjekte bzw. -daten
				\item \textbf{Verifikation} der Ergebnisse (mit \texttt{assert*}-Methoden)
			\end{enumerate}
			\vspace{1em}
			\noindent
			Auch bekannt als "Triple-A"-Pattern: \textbf{A}rrange, \textbf{A}ct, \textbf{A}ssert
			\begin{figure}[!htb]
				\centering
				\includegraphics[keepaspectratio, height=3cm]{img/testing/test_01.png}
				\caption{Beispiel-Testfall}
				\label{fig:test_01}
			\end{figure}
		
				\paragraph{Self-Validating mit assert*-Methoden}
				
				Einfacher Vergleich zwischen einem Soll- und Ist-Wert, Methoden der Klasse \texttt{org.junit.jupiter.api.Assertions}, für viele Daten überladen (elementar oder Klasse \texttt{Object})
				
				\begin{figure}[!htb]
					\centering
					\includegraphics[keepaspectratio, height=3.5cm]{img/testing/test_asserts.png}
					\caption{Beispiele für assert*-Methoden}
					\label{fig:test_asserts}
				\end{figure}
			
				\paragraph{Annotations für Test-Methoden}
				
				Zur Konfiguration von Tests stehen mit JUnit verschiedene Annotationen zur Verfügung:
			
				\begin{figure}[!htb]
					\centering
					\includegraphics[keepaspectratio, height=5.5cm]{img/testing/test_annotations.png}
					\caption{Annotationen im Code für Testfälle}
					\label{fig:test_annotations}
				\end{figure}
			
				\paragraph{Namenskonventionen}
				
				\begin{itemize}
					\item \textbf{Testklasse:}\\
						Für Klasse \texttt{Demo}: \texttt{DemoTest}\\
						\texttt{Test} als Appendix, alle Testklassen ind \texttt{/src/main/test}!
					
					\item \textbf{Testmethoden:}\\
						Für Methode \texttt{foo(...)}: \texttt{testFoo[Xyz]()}\\
						\texttt{test} als Präfix, \texttt{Xyz} als freie, ergänzbare Fallbeschreibung, Testmethoden haben keine formalen Parameter
				\end{itemize}
			
			\subsubsection{Empfehlungen}
			
			\begin{itemize}
				\item Besser viele kleine Testmethoden als wenig grosse \\
				$\rightarrow$ im Fehlerfall bessere Selektivität
				
				\item Wenige \texttt{assert*}-Statements pro Testmethode \\
				$\rightarrow$ höhere Selektivität im Fehlerfall und übersichtlicher
				
				\item Methoden mit Rückgabewert am einfachsten testbar\\
				$\rightarrow$ Bei void-Methoden ggf. indirekt über Statusabfragen auf getestetes Objekt testen
				
				\item Getter \& Setter: gemeinsam oder indirekt "beiläufig" testen
				
				\item \textbf{Nie} Schnittstellen oder Sichtbarkeit nur für Testbarkeit ändern
				
				\item Klasse/Methode zu schwerig zu testen? $\rightarrow$ Hinterfrage mal deren Design...
			\end{itemize}
			
		\subsection{Sie kennen die Vorteile von Test First}
		
		Wir testen \textbf{kontinuierlich} während der Implementation, um von Beginn an Gewissheit zu haben, dass es funktioniert.\\
		Fehler finden, bevor man sie macht.
		Fehler finden, bevor man sie implementiert hat.
		Oder Fehler im Ansatz finden, bevor es jemand anders tut.
		Bullshitsätz...
		
			\subsubsection{Test First}
			
			\textbf{Immer vor der Implementation die Testfälle schreiben!}\\
			Vorteile dabei:
			\begin{itemize}
				\item Beim Schreiben der Testfälle denkt man automatisch an Implementation des zu testenden Codes\\
				$\rightarrow$ Implementation "reift" sozusagen beim Schreiben der Testfälle heran
				
				\item Ausnahmen und Sonderfälle fallen auf, welche bei der eigentlichen Implementation dann "automatisch" berücksichtigt werden
				
				\item Sobald die Komponente fertig implementiert ist, kann sie sofort getestet werden
			\end{itemize}
		
		\subsection{Code Coverage (Codeabdeckung)}
		
		\begin{itemize}
			\item Code Coverage = Metrik, welche zur Lauftzeit misst, welche Quellcodezeilen von Testfällen abgearbeitet wurden
			\item Wird typischerweise bei Ausführung der Unit-Testfällen (bspw. durch JUnit) durchgeführt\\
				$\rightarrow$ oder zur "normalen" Laufzeit, zur Messung welche Funktionen effektiv genutzt werden
			\item Ermöglicht eine Aussage, wie umfassend der Code getestet wurde\\
			(gezielte Effizienzsteigerung der Testfälle)
			\item Hohe Code Coverage ist \textbf{kein} Beweis für gute Testfälle oder Fehlerfreiheit!
		\end{itemize}
	
		\subsection{Unit Tests - Bilanz}
		
		\textbf{Positiv:}
		\begin{itemize}
			\item Testen ist vollständig in Implementationsphase integriert $\rightarrow$ Aufgabe des Entwicklers
			\item Neue / veränderte Methoden sind unmittelbar, reproduzierbar \& schnell testbar (regressiv)
			\item Test First: problemlos möglich und motivierend
			\item Automatisiertes, übersichtliches Feedback / Reporting
			\item Messung von Codeabdeckung integrierbar
		\end{itemize}
		\textbf{Negativ:}
		\begin{itemize}
			\item Qualität der Testfälle im Auge behalten $\rightarrow$ \textbf{Qualität vor Quantität}
			\item Für GUI(-Komponenten) aufwändiger
			\item In manchen Architekturen / Umgebungen schwierig umsetzbar
		\end{itemize} 
		
	\newpage
	\section{Automatisiertes Testing}
	
		\subsection{Sie kennen die verschiedenen Testarten und sind in der Lage gute Unit-und Integrationstests zu schreiben}
		
			\subsubsection{repeat(Unit Tests)}
			
			\begin{itemize}
				\item Häufig mit Komponenten/Modul/Entwickler-Tests gleichgesetzt
				\item Funktionale Tests von einzelnen, in sich abgeschlossenen Einheiten\\
						(typisch Klasse, aber auch Komponente oder Modul)
				\item Ziele von guten Unit-Tests:
					\begin{itemize}
						\item schnell, einfach ausführbar, selbstvalidierend (assert*-Methoden), automatisiert
						\item mögl. ohne Abhängigkeiten zu anderen Klassen/Komponenten/Modulen (lose Kopplung)
						\item Während Entwicklung geschrieben und ausgeführt (in IDE oder durch CI)
					\end{itemize}
				\item Gute Unterstützung durch Frameworks (JUnit, TestNG etc.)
			\end{itemize}
		
			\subsubsection{Integrationstests (JUnit)}
			
			\begin{itemize}
				\item \textbf{Namenskonvention:}\\
					\texttt{XyzIT} für Integrationstest (Klassenname + Appendix \texttt{IT})\\
					Ablegen unter \texttt{/src/test/java}
					
				\item Unterscheidung ergibt sich "nur" durch:\\
				Zeitpunkt der Ausführung, Laufzeit und Abhängigkeiten während der Ausführung
				
				\item Eigene Apache Maven Stage (\texttt{integration-test}) für Integrationstests\\
				Getrennte Plugins \texttt{surefire} und \texttt{failsafe} weisen Testresultate auch getrennt aus\\
				(Unit und Integration)
			\end{itemize}
		
			\subsubsection{Unit- vs. Integrationstests}
			
			\begin{itemize}
				\item \textbf{Unit-Tests} sind wirklich Unit-Tests, wenn sie auf beliebigem System und jederzeit lauffähig sind und (bei Java) auf unterschiedlichen Betriebssystemen laufen
				
				\item \textbf{Konsequenz:}\\
				Testfälle, die mit Dateisystem interagieren oder Sockets verwenden (auch wenn nur auf \texttt{localhost}), sind streng gesehen bereits Integrationstests
				
				\item Unit-Tests dürfen somit nie aufgrund von "Fremdeinflüssen" fehlschlagen\\
				(bspw. falscher Pfad, Platz, Zugriffsrechte etc.)
				
				\item \textbf{Empfehlungen:}
					\begin{itemize}
						\item Bewusst zwischen beiden Kategorien trennen
						\item Im Team auf gemeinsame Philosophie der Trennung der Kategorien einigen\\
						(Kann auch mal projektspezifisch sein)
						\item Je mehr als Unit Tests realisiert wird, desto besser
						\item Jeder automatisierte Test hilft
						\item Hilfsmittel wie Code Coverage oder Mocking nutzen
					\end{itemize}
			\end{itemize}
		
		
		\subsection{Sie nutzen Werkzeuge zur Messung der Codeabdeckung aktiv zu Verbesserung Ihres Codes und der Testfälle}
		
		Ja klar tu ich das!
		
		\newpage
		\subsection{Sie kennen das Prinzip der Dependency Injection}
		
		\begin{itemize}
			\item Schlechte Testbarkeit durch zu stark gekoppelte Abhängigkeiten\\
					$\rightarrow$ Schlechtes Design
			\item High-Level-Klassen sollen nicht von Low-Level Klassen abhängig sein, \\
			sondern beide von Interfaces
			\item Interfaces sollen nicht von Details, sondern Details von Interfaces abhängig sein!
			\item Isolation von Klassen, Auflösung von Abhängigkeiten durch Dependency Injection
			\item Dependency Inversion Principle - DIP (aus S.O.L.I.D.)
		\end{itemize}
	
			\subsubsection{Dependency Injection - Beispiel}
		
			Eine Klasse \texttt{PersonPersistor} soll implementiert werden, welche \texttt{Person}-Objekte als \texttt{String} serialisiert und in einer Datei speichert.
			Es existiert eine Implementation \texttt{StringPersistorFile}, welche wiederverwendet wird:
			
			\begin{figure}[!htb]
				\centering
				\includegraphics[keepaspectratio, height=5cm]{img/testing/di_01.png}
				\caption{Erster Lösungsansatz für das Problem}
				\label{fig:di_01}
			\end{figure}
			
			\textbf{EINE ZIEMLICH BEKNACKTE LÖSUNG FÜR TESTING!}\\
			
			\begin{lstlisting}
public final class PersonPersistor {
	private final StringPersistorFile spm = newStringPersistorFile();
	...
}
			\end{lstlisting}
			
			\begin{itemize}
				\item Einfach für die Realisierung, ist aber der einzige Vorteil, negative Aspekte:
					\begin{itemize}
					\item Typen und Implementation sind stark gekoppelt
					\item Abhängigkeit zur Implementationsklasse (obwohl ein Interface existieren würde)
					\item Unflexible Implementation
					\end{itemize}
				\item Wir wollen die Funktionalität der \texttt{PersonPersistor} testen, um Strings zu serialisieren und wieder zu deserialisieren
				\item \texttt{StringPersistorFile} greift aber auf das Dateisystem zu, weshalb die Abhängigkeit uns in die Kategorie der \textbf{Integrationstests} wirft\\
				Ausserdem würden wir den bereits getesteten \texttt{StringPersistorFile} nochmals testen\\
				$\rightarrow$ Selektivität des Testfalls sinkt
				\item Man müsste die Abhängigkeit auf den intern verwendeten \texttt{StringPersistorFile} durch etwas anderes ersetzen können
			\end{itemize}
			\vspace{1em}
			\noindent
			Lösung auf der nachfolgenden Seite
		
		\newpage
		
				\paragraph{Dependency Injection}
				
				Eine Klasse/Komponente erzeugt ihre Abhängigkeiten nicht selber, sondern lässt sich diese (wahlweise) auch von Aussen übergeben.
				
				\begin{figure}[!htb]
					\centering
					\includegraphics[keepaspectratio, height=5cm]{img/testing/di_02.png}
					\caption{Besserer Lösungsansatz für Testing mit Dependency Injection}
					\label{fig:di_02}
				\end{figure}
			
				\begin{itemize}
					\item Der konkrete Typ (Implementation) wird durch ein Interface ersetzt\\
					$\rightarrow$ Kopplung nimmt stark ab
					
					\item Es können so verschiedene, alternative Implementierungen genutzt werden\\
					$\rightarrow$ Andere Möglichkeiten / Ansätze testen
					
					\item Dependency Inversion Principle\\
					$\rightarrow$ Resultiert in besserer "Separation of Concerns"
					
					\item Testbarkeit wird massiv vereinfacht, man kann während Tests eine alternative Implementation als Platzhalter einfügen $\rightarrow$ \textbf{Test Double}
					
					\item Integrationstest werden wieder zu Unit Tests, schnellere \& selektivere Tests
				\end{itemize}
		
		\subsection{Sie wissen was Test Doubles sind und können Mocking-Frameworks einsetzen}
		
			\subsubsection{Test Doubles}
			
			\begin{itemize}
				\item "Double" ist Platzhalter für eine echte, produktive Implementation während des Tests
				\item Oberbegriff "Test Doubles" umfasst verschiedene, interessante Spezialisierungen
				\item Test Doubles sollen Aufwand für Integrationstests reduzieren, indem stattdessen mehr Testfälle als Unit-Tests realisiert werden
				\item Möglichst viel mit Unit-Tests prüfen, weil:
					\begin{itemize}
						\item Erste Teststufe, direkt bei Entwickler
						\item Schnell, häufig, überall lauffähig, vollständig automatisiert
						\item Hohe Selektivität der Testfälle
					\end{itemize}
				\item Test Doubles sind auch innerhalb von Integrationstests nützlich\\
					$\rightarrow$ Gezielte Isolation der Tests von einzelnen Integrationen (Abhäng. von anderen Systemen)
				\item Für Test Doubles muss gutes Design der Software vorliegen\\
					$\rightarrow$ Einsatz von Interfaces lohnt sich (fast) immer, da ein Interface verschiedene Implementationen zulässt, minimum eine "echte" und eine Test-Implementation
				\item Wahl der Implementation muss zur Test-Laufzeit beeinflusst werden können\\
					$\rightarrow$ per Dependency Injection (manuell oder per Framework)\\
					(\textbf{Achtung:} Sicherung nötig, dass das nicht in der \textbf{Produktion} passiert)
			\end{itemize}
		
		\newpage
		
			\begin{figure}[!htb]
				\centering
				\includegraphics[keepaspectratio, height=4cm]{img/testing/doubles.png}
				\caption{Übersicht über alle verfügbaren Test-Doubles}
				\label{fig:doubles}
			\end{figure}
		
			\paragraph{Dummy}
			
				\begin{itemize}
					\item Sehr primitive, leere Ersatzimplementation, wird als aktueller Parameter an Methoden übergeben\\
					$\rightarrow$ Aktueller Parameter ist zwar notwendig für Test, dessen Nutzung und Implementation (für Test) aber irrelevant
					\item Dummy: dient funktionsloser Entkopplung der beim Test unerwünschten Abhängigkeiten
				\end{itemize}
				\begin{quote}
					\textbf{Beispiel:}\\
					Einem Objekt muss bspw. ein Logger übergeben werden.
					Dieser soll aber nichts machen, da Loggen nicht das eigentliche Testziel ist.
				\end{quote}
		
			\paragraph{Stub}
			
				\begin{itemize}
					\item Einfache Implementation, die mit möglichst geringem Aufwand sinnvolle, vordefinierte Werte (bspw. Konstanten)zurückliefert
					\item Erlaubt sogenanntes "State"-Testing\\
						$\rightarrow$ State durch Daten repräsentiert, State bei Stubs in der Regel konstant
					\item Für verschiedene Testziele ggf. auch mehrere untersch. Stubs erstellen
				\end{itemize}
				\begin{quote}
					\textbf{Beispiel:}\\
					Eine Klasse für Authentifizierung testen, welche...\\
					- Beliebige Nutzer/Passwörter akzeptiert: \texttt{login = true}\\
					- Niemanden akzeptiert: \texttt{login = false}
				\end{quote}
			
			\paragraph{Spy}
			
				\begin{itemize}
					\item Alternative Implementation, welche dynamische Werte zurückliefern kann.
					Der Spy merkt sich gleichzeitig auch die Aufrufe der Methode\\
					(Anzahl/Häufigkeit, Paramater, Zeitpunkt, Exceptions etc.)
					\item Nach Interaktion können aufgezeichnete Ereignisse zur Verifikation des Testfalls genutzt werden.
					\item Erlaubt "Behavior"-Testing (Verhalten)
				\end{itemize}
				\begin{quote}
					\textbf{Beispiel:}\\
					Wurde auf dem beim Testkandidaten registrierten \texttt{ActionListener}(-Spy)\\
					die Methode \texttt{actionPerformed()} auch tatsächlich aufgerufen?
				\end{quote}
			
			\paragraph{Mock}
			
				\begin{itemize}
					\item Spezialisierung des Spy, welcher dynamische Werte zurückliefern kann und die korrekte Interaktion selber verifizieren kann $\rightarrow$ Abgrenzung zum Spy
					\item Typisch mithilfe von Mock-Frameworks zur Laufzeit für jeden Testfall als individuelle Mock-Objekte erstellt (Proxy-Pattern, GoF)\\
					$\rightarrow$ Verhalten für jeden Testfall dynamisch / programmatisch konfiguriert
					\item Sehr ähnlich zu Spy, Unterschied ist jedoch der Ort der Verifikation, Mocks sind spezifischer
				\end{itemize}
			
			\newpage
			
			\paragraph{Fake}
			
				\begin{itemize}
					\item Alternative Implementation, welche eine Komponente \\
					mit vernünftigem Aufwand vollständig ersetzen kann
					\item Ermöglicht vollständige Entkopplung von einer Abhängigkeit\\
						Trade-Off $\rightarrow$ Aufwand der Implementation des Fake muss in vernünftigem Verhältnis zum Nutzen sein (Unit vs. Integration)
				\end{itemize}
				\begin{quote}
					\textbf{Beispiel:}\\
					Abhängigkeit von Webservices durch lokale Fake-Implementation ersetzt\\
					- Kommunikation fällt weg, ist somit schneller\\
					- Implementation trotzdem vorhanden (wenn nicht zu komplex), \\
					idealerweise auch wiederverwendet
				\end{quote}
		
		\subsubsection{Effektives Testen mit Test Doubles - Beispiele}
		
		\textbf{Mockito} - bewährtes Testing-Framework für Java.\\
		In Maven einbinden mit \texttt{org.mockito:mockito-core:2.23.0}\\
		Viele statische Klassen auf der Klasse \texttt{org.mockito.Mockito}.\\
		Bestenfalls statischer Import aller Funktionen:\\
		\texttt{import static org.mockito.Mockito.*;}
		
		\paragraph{Test mit Fake}
		
			Für Testausführung wird Fake-Implementation \texttt{StringPersistorMemory} (statt \texttt{File}) verwendet, welche Strings nur im Memory "speichert":
			
			\begin{lstlisting}
@Test
public void testGetEmptyList() {
	final Person Persistorinstance = 
		new PersonPersistor(new StringPersistorMemory());
	assertThat(instance.getList()).isEmpty();
}
			\end{lstlisting}
			\noindent
			Für diesen Testfall resultiert:
			\begin{itemize}
				\item Keine Abhängigkeit mehr zum Dateisystem
				\item Unit-Test (kein Integrationstest)
				\item Testet viel weniger Dritt-Code und wird damit selektiver
			\end{itemize}
		
		\paragraph{Test mit Mock}
		
			Für Testausführung wird Mock (oder Spy) verwendet, welcher direkt im Testfall erzeugt / konfiguriert wird:
			
			\begin{lstlisting}
@Test
public void testGetEmptyList() {
	finalStringPersistor mock = 
									mock(StringPersistor.class);
	when(mock.get(0)).thenReturn(Collections.emptyList());
	finalPersonPersistorinstance = 
									newPersonPersistor(mock);
	assertThat(instance.getList()).isEmpty();
}
			\end{lstlisting}
			\noindent
			Der Testfall:
			\begin{itemize}
				\item Keine Abhängigkeit mehr zu einer Implementation
				\item Selektivität ist maximal
			\end{itemize}
				
		\newpage
		
		\subsubsection{Empfehlungen}
		
		\begin{itemize}
			\item Gewisse Klassen sind zu aufwändig für Mocking
			\item Gewisse Klassen sind zu einfach für Mocking
			\item Verständlichkeit des Testcodes am wichtigsten, wenn Testfall durch Mocking zu kompliziert wird, dass man ihn nicht mehr versteht, hed mer huere verlore.
			\item Überleged si sich öbs sich lohnt. Stiiged si doch langsam id Technik ii, si esch absolut faszinierend!\\
			\textit{- Roli Gisler}
		\end{itemize}
	
			\paragraph{Wann setzt man was ein?}
			
			\begin{itemize}
				\item \textbf{Dummy / Stub:}\\
				Einfache Ersatzimplementationen, um bessere Testisolation zu erreichen\\
				Geringer Aufwand $\rightarrow$ höhere Selektivität / Stabilität der Testfälle (einfach)
				
				\item \textbf{Spy / Mock:}\\
				"Universalwaffen" für Behavior-Testing mithilfe Mocking-Frameworks.
				Können auch zur Realisierung von Stubs / Dummies genutzt werden (komplexer)
				
				\item \textbf{Fake:}\\
				Aufwändige Implementation, zur vollständigen Entkopplung vom Original.\\
				Muss sich lohnen (aufwändig)\\
				(Ja aber was wänn de Fake besser isch as de Original..??)\\
				
				\item Design ist entscheidend:\\
				So oft wie möglich Interfaces verwenden, um schneller alternative Implementationen zu integrieren
			\end{itemize}
				
	\newpage
	\section{Software Architektur}
		
		%TODO
		
	\newpage
	\section{Grafisches User Interface - mit JavaFX}	
		
		%TODO
		
	\newpage
	\section{Persistierung - JPA und OR Mapping}
	
		%TODO
		
	\newpage
	\section{Persistierung - Java Persistence Query Language (JPQL)}
		
		%TODO
		
	\newpage
	\section{Kommunikation - Remote Method Invocation (RMI)}
	
		%TODO
	
	\newpage
	\section{Web Services - REST}
	
		%TODO
		
		
\end{document}