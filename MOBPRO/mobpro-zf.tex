\documentclass[a4paper]{article}

\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage[scaled]{helvet}
\renewcommand{\familydefault}{\sfdefault}

\usepackage[margin=80pt]{geometry}

\usepackage{multicol}
\usepackage{graphicx}
\usepackage{caption}

\usepackage[table,xcdraw]{xcolor}
\usepackage{courier}
\usepackage{subcaption}

\usepackage{enumitem}
\setlist{nosep}

\usepackage [autostyle]{csquotes}
\MakeOuterQuote{"}

\usepackage[hidelinks]{hyperref}
\hypersetup{colorlinks=false}

\usepackage{listings}
\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	language=Java,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3
}


\title{\textbf{MOBPRO - Mobile Programming\\
Zusammenfassung FS 2019}}
\date{\today}
\author{Maurin D. Thalmann}

\begin{document}
	\pagenumbering{gobble}
	\maketitle
	\newpage
	\pagenumbering{arabic}
	\tableofcontents
	\newpage
	
	\section{Android 1 - Grundlagen}
	Informationen zur Androidprogrammierung können stets dem Android Developer Guide entnommen werden unter: \textit{\href{https://developer.android.com/}{developer.android.com}}
	Apps sollen grundsätzlich gegen das aktuellste API entwickelt werden, aktuell API Level 28 Android 9 "Pie".
	Im Gradle-Build-Skript werden deshalb folgende SDK-Versionen festgehalten:
\vspace{1em}
	\begin{description}
		\item[\textit{minSdkVersion}] Mindestanforderung an die SDK, Minimum-Version
		\item[\textit{targetSdkVersion}] Ziel-SDK-Version, auf welcher die App lauffähig sein soll
		\item[\textit{compileSdkVersion}] Version mit welcher die App (APK) erstellt wird, meist gleich der Target-Version	
	\end{description}
\vspace{1em}
	\textbf{ART (Android Runtime)} verwaltet Applikationen bzw. deren einzelne Komponenten:
	\begin{itemize}
		\item Komponente kann andere Komponente mit Intent-Mechanismus aufrufen
		\item Komponenten müssen beim System registriert werden (teilweise mit Rechten = Privileges)
		\item System verwaltet Lebenszyklus von Komponenten: Gestartet, Pausiert, Aktiv, Gestoppt, etc.
	\end{itemize}
\subsection{Komponenten}
	Applikationen sind aus Komponenten aufgebaut, die App verwendet dabei eigene Komponenten (min. eine) oder Komponenten von anderen, existierenden Applikationen.
\begin{table}[h!]
	\begin{tabular}{ l | p{11cm} }
		\textbf{\textit{Name}}               & \textbf{\textit{Beschreibung}} \\
		\hline
		\textbf{Activity}           & UI-Komponente, entspricht typischerweise einem Bildschirm \\
		\textbf{Service}            & Komponente ohne UI, Dienst läuft typischerweise im Hintergrund \\
		\textbf{Broadcast Receiver} & Event-Handler, welche auf App-interne oder systemweite Broadcast-Nachrichten reagieren \\
		\textbf{Content Provider}   & Komponente, welche Datenaustausch zwischen versch. Applikationen ermöglicht
	\end{tabular}
\end{table}

\noindent
\textbf{Activity} entspricht einem Bildschirm, stellt UI-Widgets dar, reagiert auf Benutzer-Eingabe \& -Ereignisse. Eine App besteht meist aus mehreren Activities / Bildschirmen, die auf einem "Stack" liegen. \\
Basisklasse: \textit{android.app.Activity} \\
\textbf{Service} läuft typischerweise im Hintergrund für unbeschränkte Zeit, hat keine graphische Benutzer\-schnittstelle (UI), ein UI für ein Service wird immer von einer Activity dargestellt. \\
Basisklasse: \textit{android.app.Service} \\
\textbf{Broadcast Receiver} ist eine Komponente, welche Broadcast-Nachrichten empfängt und darauf reagiert. Viele Broadcasts stammen vom System (Neue Zeitzone, Akku fast leer,...), App kann aber auch interne Broadcasts versenden. \\
Basisklasse: \textit{android.content.BroadcastReceiver}\\
\textbf{Content Provider} ist die einzige \textit{direkte} Möglichkeit zum Datenaustausch zwischen Android-Apps. Bieten Standard-API für Suchen, Löschen, Aktualisieren und Einfügen von Daten. \\
Basisklasse: \textit{android.content.ContentProvider}
\newpage
\subsection{Das Android-Manifest}
\textbf{AndroidManifest.xml} dient dazu, alle Komponenten einer Applikation dem System bekannt zu geben. Es enthält Informationen über Komponenten der Applikation, statische Rechte (Privileges), Liste mit Erlaubnissen (Permissions), ggf. Einschränkungen für Aufrufe (Intent-Filter). Es beschreibt die statischen Eigenschaften einer Applikation, beispielsweise: \\
\textit{(Diese Infos werden bei der App-Installation im System registriert, zusätzliche Infos (Version, ID, etc.) befinden sich im Gradle-Build-Skript (können build-abhängig sein))}

\begin{itemize}
	\item Java-Package-Name
	\item Benötigte Rechte (Internet, Kontakte, usw.)
	\item Deklaration der Komponenten
	\begin{itemize}
		\item Activities, Services, Broadcast Receivers, Content Providers
		\item Name (+ Basis-Package = Java Klasse)
		\item Anforderungen für Aufruf (Intent) für A, S, BR
		\item Format der gelieferten Daten für CP
	\end{itemize}
\end{itemize}
\begin{figure}[htb!]
	\centering
	\includegraphics[width=12cm]{img/manifestxml.jpg}
	\caption{Beispiel eines Android-Manifests}
	\label{fig:manifestxml}
\end{figure}
\subsection{Activities \& Aufruf mit Intents}
Zwischen Komponenten herrscht das Prinzip der losen Kopplung:
\begin{itemize}
	\item Komponenten rufen andere Komponenten über Intents (= Nachrichten) auf
	\item Offene Kommunikation: Sender weiss nicht ob Empfänger existiert
	\item Parameterübergabe als Strings (untypisiert)
	\item Parameter: von Empfänger geprüft, geparst \& interpretiert (oder ignoriert)
	\item Keine expliziten Abhängigkeiten $\rightarrow$ Robuste Systemarchitektur
\end{itemize}
\newpage
\begin{figure}[htb!]
	\centering
	\includegraphics[width=7.5cm]{img/intents_comm.png}
	\caption{Kommunikation zwischen Komponenten mit Intents}
	\label{fig:intents_comm}	
\end{figure}
\noindent
Intents werden benutzt, um Komponenten zu benachrichtigen oder um Kontrolle zu übergeben. Es gibt folgende zwei Arten von Intents:
\begin{description}
	\item[Explizite Intents] adressieren eine Komponente direkt
	\item[Implizite Intents] beschreiben einen geeigneten Empfänger
\end{description}
\textbf{WICHTIG:} Activities müssen immer im Manifest deklariert werden, da sie sonst nicht als "public" gelten und eine Exception schmeissen. Das geht auch ganz einfach folgendermassen im Manifest unter "application":
\begin{lstlisting}
<activity android:name=".Sender" />
<activity android:name=".Receiver" />
\end{lstlisting}
\subsubsection{Beispielaufruf Expliziter Intent}
\textbf{Sender Activity:}
\begin{lstlisting}
public void onClickSendBtn(final View btn) {
	Intent intent = new Intent(this, Receiver.class); 
	// Receiver.class ist hier der explizite Empfaenger
	intent.putExtra("msg", "Hello World!");
	startActivity(intent);
}
\end{lstlisting}
\textbf{Receiver Activity:}
\begin{lstlisting}
public void onCreate(Bundle savedInstanceState) {
	// ...
	Intent intent = getIntent();
	String msg = intent.getExtras().getString("msg");
	displayMessage(msg);
}
\end{lstlisting}
\newpage
\subsubsection{Beispielaufruf Impliziter Intent}
\textbf{Sender Activity:}
\begin{lstlisting}
Intent browserCall = new Intent();
browserCall.setAction(Intent.ACTION_VIEW);
browserCall.setData(Uri.parse("http://www.hslu.ch"));
startActivity(browserCall);	
\end{lstlisting}
\textit{ACTION\_VIEW} ist hierbei kein expliziter Empfängertyp, sondern nur eine gewünschte Aktion. Die mitgege\-bene URL wird auch ein \textit{Call Parameter} genannt. Gesucht ist in diesem Fall eine Komponente, welche eine URL anzeigen/verwenden kann.\\
\subsection{Activities \& Subactivities}
\textbf{Activity Back Stack:} Activities liegen aufeinander wie ein Stapel Karten, neuste Activity zuoberst und in der Regel ist nur diese sichtbar (Durch Transparenz sind hier Ausnahmen möglich).
Durch "back" oder "finish" wird die oberste Karte entfernt und man kehrt zur zweitletzten Activity zurück. Mehrere Instanzen derselben Activity wären mehrere solche Karten, das Verhalten kann jedoch konfiguriert werden (z.Bsp. maximal eine Instant, mehrere Activities öffnen, etc.)\\
\textbf{(Sub-)Activities und Rückgabewerte:} Eine Activity kann Rückgabewerte einer anderen (Sub-)Activity erhalten.
\begin{lstlisting}
// 1. Aufruf der SubActivity mit
startActivityForResult(intent, requestId)

// 2. SubActivity setzt am Ende Resultat mit
setResult(resultCode, intent) // intent als Wrapper fuer Rueckgabewerte

// 3. SubActiity beendet sich mit
finish()

// 4. Nach Beendung der SubActivity wird folgendes im Aufrufer aufgerufen:
onActivityResult(requestId, resultCode, intent)
// resultCode: RESULT_OK, RESULT_CANCELLED
\end{lstlisting}
\subsection{Lebenszyklus \& Zustände von Applikationen/Activities}
Das System kann Applikationen bei knappem Speicher ohne Vorwarnung terminieren (nur Activities im Hintergrund, dies geschieht unbemerkt vom User, die App wird bei Zurücknavigation wiederhergestellt). Eine Applikation kann ihren Lebenszyklus demnach nicht kontrollieren und muss in der Lage sein, ihren Zustand speichern und wieder laden zu können. Applikationen durchlaufen mehrere Zustände in ihrem Lebenszyklus, Zustandsübergänge rufen Callback-Methoden auf (welche von uns überschrieben werden können.\\

\noindent
\textbf{Activity-Zustände:}
\begin{table} [h!]
	\begin{tabular}{ c | p{10cm} }
		\textbf{Zustand} & \textbf{Beschreibung} \\ \hline
		\textbf{Running} & Die Activity ist im Vordergrund auf dem Bildschirm (zuoberst auf dem Activity-Stack für die aktuelle Aufgabe). \\ \hline
		\textbf{Paused} & Die Activity hat den Fokus verloren, ist aber immer noch sichtbar für den Benutzer. \\ \hline
		\textbf{Stopped} & Die Activity ist komplett verdeckt von einer andern Activity. Der Zustand der Activity bleibt jedoch erhalten.
	\end{tabular}
\end{table}
\newpage
\subsubsection{Lifecycle einer Applikation}
\begin{figure}[h!]
	\centering
	\includegraphics[width=13cm]{img/lifecycle.jpg}
	\caption{Lifecycle einer Applikation}
	\label{fig:lifecycle}
\end{figure}
\begin{figure}[h!]
	\centering
	\includegraphics[width=11cm]{img/lifetime.jpg}
	\caption{Lebenszeiten der einzelnen App-Zustände}
	\label{fig:lifetime}
\end{figure}
\newpage
\subsection{Charakterisierung einer Activity}
\begin{itemize}
	\item Muss im Manifest deklariert werden
	\item GUI-Controller
	\begin{itemize}
		\item Repräsentiert eine Applikations-/Bildschirmseite
		\item Definiert Seitenlayout und GUI-Komponenten
		\item Kann aus Fragmenten ( = "Sub-Activities") aufgebaut sein
		\item Reagiert auf Benutzereingaben
		\item Beinhaltet Applikationslogik für dargestellte Seite
	\end{itemize}
\end{itemize}
\textbf{Beispiel einer Activity:}
\begin{lstlisting}
public class Demo extends Activity {
	// Called when the Activity is first created
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.main); // Definiert Layout und UI
	} 
}	
\end{lstlisting}
\subsubsection{Zustandsänderung - Hook-Methoden}
Das System benachrichtigt Activities durch Aufruf einer der folgenden Methoden der Klasse \textit{Activity}:
\begin{itemize}
	\item void onCreate(Bundle savedInstanceState)
	\item void onStart() / void onRestart()
	\item void onResume()
	\item void onPause() $\rightarrow$ \textit{bspw. Animation stoppen}
	\item void onStop()
	\item void onDestroy() $\rightarrow$ \textit{bspw. Ressourcen freigeben}
\end{itemize}
Durch das Überschreiben dieser Methoden können wir uns in den Lebenszyklus einklinken. Immer \textbf{super()} aufrufen, sonst wirft es eine Exception.
\newpage
\subsection{Android - Hinter den Kulissen}
\begin{figure}[h!]
	\centering
	\includegraphics[width=11cm]{img/androidstack.jpg}
	\caption{Der Android-Stack}
	\label{fig:androstack}
\end{figure}
\begin{itemize}
	\item \textbf{Linux-Kernel:} OS, FS, Security, Drivers, ...
	\item \textbf{HAL (Hardware Abstraction Layer):} Camera-, Sensor-, ... Abstraktion
	\item \textbf{ART} (Android Runtime)
	\begin{itemize}
		\item Jede App in eigenem Prozess
		\item Optimiert für mehrere JVM auf low-memory Geräten
		\item Eigenes Bytecode-Format (Crosscompiling)
		\item JIT und AOT Support
	\end{itemize}
	\item \textbf{Native C/C++ Libriaries:} Zugriff via Android NDK
	\item \textbf{Android Framework:} Android Java API
	\item \textbf{Applications:} System- und eigene Apps
\end{itemize}
\newpage
\subsubsection{Android-Security-Konzept}
\textbf{Sandbox-Konzept:} 
\begin{itemize}
	\item Jede laufende Android-Anwendung hat seinen eigenen Prozess, Benutzer, ART-Instanz, Heap und Dateisystembereich $\rightarrow$ jedes App hat eigenen Linux-User
	\item Das Berechtigungssystem von Linux ist Benutzer-basiert, es betrifft deshalb sowohl den Speicherzugriff wie auch das Dateisystem. 
	\item Anwendungen signieren: erschwert Code-Manipulationen und erlaubt das Teilen einer Sandbox bei gleicher sharedUser-ID
	\item Berechtigungen werden im Manifest deklariert, kontrollierte Öffnung der Sandbox-Restriktionen
\end{itemize}
\begin{figure}[htb!]
	\centering
	\includegraphics[width=12cm]{img/securitymodel.jpg}
	\caption{Android Security-Modell}
	\label{fig:secumodel}
\end{figure}

\newpage
\section{Android 2 - Benutzerschnittstellen}

\subsection{GUI einer Activity}

GUI wird als XML definiert, der Name resultiert in einer Konstante: \textit{\textbf{R}.layout.xxx}. Diese wird im \textit{onCreate()} einer Activity mit \textit{setContentView()} angegeben.

\begin{figure}[htb!]
	\centering
	\includegraphics[width=10cm]{img/gui_xml_example.jpg}
	\caption{Beispiel eines XML für ein Layout}
	\label{fig:guixmlexamp}
\end{figure}
\noindent
Je nach Layout müssen die Elemente unterschiedlich konfiguriert werden, was bei der Arbeit mit dem Layout-Editor nicht offensichtlich, aber trotzdem gut zu wissen ist. \\
Ein Android-UI ist hierarchisch aufgebaut und besteht aus \textbf{ViewGroups} (Cointainer für Views oder weitere ViewGroups, angeordnet durch Layout) und \textbf{Views} (Widgets). Sollte auf unterschiedlichen Bildschirmgrössen gleich aussehen (Elemente deshalb \textbf{relativ} und nicht absolut positionieren)

\begin{figure}[htb!]
	\centering
	\includegraphics[width=10cm]{img/xml_layouts.jpg}
	\caption{Layout-Varianten bei Android}
	\label{fig:xmllayouts}
\end{figure}
\noindent
Schachtelung möglich, aber nicht effizient, wenn möglich immer das Constraint-Layout verwenden. Layouts spezifiziert man auf zwei verschiedene Arten:
\begin{itemize}
	\item \textbf{Statisch / Deklarativ (XML)}
	\item \textit{Grundsätzlich in MOBPRO verwendet, bietet viele Vorteile (Deklarativ, weniger umständlich als Code, Struktur eminent, Umformungen ohne Rekompilierung möglich...)}
		\begin{itemize}
			\item Deklarative Beschreibung des GUI als Komponentenbaum
			\item XML-Datei unter \textit{res/layout}
			\item Referenzen auf Bilder/Texte/etc.
			\item Typischerweise ein XML pro Activity
		\end{itemize}
	\item \textbf{Dynamisch (in Java)}
	\item \textit{Jedes XML hat eine korrespondierende Java-Klasse, XML $\rightarrow$ Java = Inflating}
		\begin{itemize}
			\item Aufbau und Definition des GUI im Java-Code
			\item Normalerweise nicht nötig: die meisten GUIs haben fixe Struktur
			\item Änderung von Eigenschaften während Laufzeit ist normal (Bsp. Visibility, Ausblenden einer View, wenn nicht benötigt)
		\end{itemize}
\end{itemize}
\newpage
\subsection{XML-Layout}
\begin{itemize}
	\item Jedes Layout ist ein eigenes XML-File
	\begin{itemize}
		\item Root-Element = View oder ViewGroup
		\item Kann Standard- oder eigene View-Klassen enthalten
	\end{itemize}
	\item XML können mit Inflater "aufgeblasen" bzw. instanziiert werden, damit eigene wiederverwendbare Komponenten/Templates/Prototypen erzeugt werden können
	\item Innere Elemente können unterhalb eines Parents via View-ID referenziert werden (\textit{findViewById()})
	\item Debugging mit dem Layout-Inspector	
\end{itemize}

\subsubsection{Constraint-Layout}

\begin{multicols}{2}
\begin{itemize}
	\item Erstellung von komplexen Layouts, ohne zu schachteln
	\item Elemente werden relativ mit Bedingungen platziert
	\begin{itemize}
		\item zu anderen Elementen
		\item zum Parent-Container
		\item Element-Chains (spread/pack)
	\end{itemize}
	\item Layout-Hilfen (Hilfslinien, Barriers)
\end{itemize}
\columnbreak
\begin{minipage}[c]{\columnwidth}
	\centering
	\includegraphics[width=0.7\linewidth]{img/constraintlayout.jpg}
	\captionof{figure}{Constraint Layout}
\end{minipage}
\end{multicols}

\subsubsection{LinearLayout}

\begin{multicols}{2}
\begin{itemize}
	\item Reiht Elemente neben-/untereinander auf
	\begin{itemize}
		\item kann geschachtelt werden, um Zeilen/Spalten zu formen (nicht zu tief, sonst schlechte Performanz
	\end{itemize}
	\item Eigenschaften:\\
	 \textit{(orientation, gravity, weigthSum, etc.)}
	\item Layout-Parameter für Children
	\begin{itemize}
		\item layout\_width, layout\_height
		\item layout\_margin...
		\item layout\_weight, layout\_gravity
	\end{itemize}
\end{itemize}
\columnbreak
\begin{minipage}[c]{\columnwidth}
	\centering
	\includegraphics[width=0.5\linewidth]{img/linearlayout.jpg}
	\captionof{figure}{LinearLayout}
\end{minipage}
\end{multicols}

\paragraph{Warum nutzt man trotzdem noch LinearLayout?}
\begin{itemize}
	\item Nach wie vor einfachste Lösung für Button- oder Action-Bars ("flow semantik") und einfache Screens
	\item Kaum Konfiguration nötig, robust
	\item Für scrollbare Listen mit dynamischer Anzahl Elemente besser \textit{ListView} verwenden (siehe Adapter-Views)
	\item Einsatz mit Bedacht durchaus sinnvoll
\end{itemize}
\vspace{1em}
\noindent
Es gibt noch die \textbf{ScrollView}, deren Nutzung vertikales Scrollen bei zu grossen Layouts erlaubt, sie kann jedoch \underline{nur ein Kind} haben und enthält typischerweise das Top-Level-Layout einer Bildschirmseite.

\paragraph{Pixalangaben}
\textit{(Typischerweise werden Angaben in dp verwendet, ausser sp bei Schriftgrössen.)}
\begin{itemize}
	\item \textbf{dp - density-independent:} \\ Passen sich der physischen Dichte des Screens an, dp passen sich gegenüber den realen Dimensionen eines Screens und dessen Verhältnisse an.
	\item \textbf{sp - scale-independent:} \\Ähnlich der dp-Einheit, passt sich jedoch der Schriftskalierung des Nutzers an.
	\item \textbf{px - Pixels:} \\Passen sich der Anzahl Pixel eines Bildschirms an, deren Nutzung wird nicht empfohlen.
\end{itemize}

\newpage

\subsection{Ressourcen, Konfigurationen und Internationalisierung}
\textbf{Ressourcen} sind alle Nicht-Java-Teile einer Applikation und sind im \textit{/res}-Verzeichnis abgelegt, sogennante ausgelagerte Konstanten-Definitionen. Sie werden im Layout und Java-Code über die \textbf{\textit{automatisch generierte R-Klasse}} mit ID-Konstanten (int) referenziert. Kontextabhängige Ressourcen sind möglich z.Bsp. für Sprache, Gerätetyp, Orientierung, ...\\
\textbf{Beispiele}: Strings, Styles, Colors, Dimensionen, Bilder (drawables), Layouts (portrait, landscape), Array-Werte (z.Bsp. für Spinner) und Menü-Items\\

\begin{figure}[htb!]
	\centering
	\begin{subfigure}{0.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{img/references_xml.jpg}
		\caption{Referenz in XML mit @}
	\end{subfigure}%
	\begin{subfigure}{0.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{img/references_code.jpg}
		\caption{Referenz in Code über \texttt{R}-Klasse, diese wird beim Build automatisch generiert}
	\end{subfigure}
\end{figure}
\noindent
Für verschiedene Systemkonfigurationen benötigt es unterschiedliche Ausprägungen einer Ressource, beispielsweise:
\begin{itemize}
	\item \textbf{Internationalisierung}: komplette/teilweise Übersetzung, für diese werden unterschiedliche Ordner je nach Land/Sprache und seperate .xml angelegt
	\item \textbf{Auflösungsklassen}: \texttt{ldpi} (~120dpi), \texttt{mdpi} (~160dpi), \texttt{hdpi} (~240dpi), \texttt{xhdpi} (~320dpi) 
	\item \textbf{Orientierung} des Displays: landscape / portrait
	\item Verschiedene \textbf{HW-Modelle}: HTC, Samsung, Sony, LG, ...
\end{itemize}
Default-Verzeichnisse sind innerhalb von \texttt{res/} angelegt: drawable, layout, menu, values, ...\\
Bei spezifischen Konfigurationen werden meist Kopien der Default-Verzeichnisse/Ordner mit einem Suffix angelegt, bspw. \texttt{res/strings-de-rCH}, in welchen dann die Ressourcen (XML) erneut angelegt werden.
\begin{figure}[htb!]
	\centering
	\includegraphics[width=0.3\linewidth]{img/ressources.jpg}
	\caption{Beispiel der Default-Ressourcen}
\end{figure}

\newpage
\subsection{UI-Event-Handling}
\begin{itemize}
	\item Jedes View-Element hat eine entsprechende Java-Klasse (auch View-Groups!) \\$\rightarrow$ Layout könnte auch dynamisch in Java programmiert werden
	\item APIs der einzelnen View-Klassen sind \href{http://developer.android.com/reference/android/widget/package-summary.html}{hier} oder unter "Nützliche Links" genauer beschrieben
\end{itemize}
\begin{figure}[htb!]
	\centering
	\includegraphics[width=0.5\linewidth]{img/layout_id.jpg}
	\includegraphics[width=0.5\linewidth]{img/reference_code.jpg}
	\caption{ID im Layout erfassen und Referenz im Code}
\end{figure}

\subsubsection{GUI-Events}
\begin{itemize}
	\item \textbf{Observer/Listener}: einen Listener für ein entsprechendes Event bei der View registrieren, bspw. bei \texttt{Button myButton}:\\
	\texttt{myButton.setOnClickListener(listener)}
	\item verschiedenste Event- und Listener-Typen:\\
	\texttt{OnClickListener,  OnLongClickListener,  OnKeyListener,  OnTouchListener,  OnDragListener, ...} 
	\\$\rightarrow$ \texttt{public static} Interfaces der Klasse \texttt{View}
\end{itemize}
\textbf{Ziel:} Auf Klick-Event eines Buttons reagieren
\begin{itemize}
	\item Button muss eine ID haben im layout.xml
	\item Registrierungs eines Listeners an die View (Button) im Code:
\end{itemize}
\begin{lstlisting}
Button button = (Button) findViewById(R.id.question_button_done);
button.setOnClickListener(new OnClickListener() {
	@Override
	public void onClick(View v) {
		// handler code
		buttonClicked();
	}
});
\end{lstlisting}
\textbf{onClick-Event-Registrierung in XML}
\begin{figure}[htb!]
	\centering
	\includegraphics[width=0.6\linewidth]{img/onclick.jpg}
	\caption{Definition onClick-Handler im Layout $\rightarrow$ so nur für OnClick-Events}
\end{figure}
\begin{lstlisting}
// Implementierung OnClick-Handler-Methode in der Activity
public void increaseInternalCounter(View button){
	// ... handler code ...
}
\end{lstlisting}

\newpage

\subsubsection{Exkurs: Data Binding}

\begin{figure}[htb!]
	\centering
	\includegraphics[width=0.5\textwidth]{img/data_binding_model.png}
	\caption{Modell für Data Binding}
\end{figure}
\noindent
\textbf{Data Binding:} separiert UI und Daten, synchronisiert UI mit Daten (1-, resp. 2-way-binding), verwendet «binding expressions» mit @{..} Syntax im Layout-File, um View-Attribute zu initialisieren. Anbei ein Beispiel (auskommentiert):

\begin{lstlisting}
<?xml version="1.0" encoding="utf-8"?> 
<layout xmlns:android="http://schemas.android.com/apk/res/android"> 
	<data> 
		<variable name="model" type="org.example.MyModel"/> 
	</data>  // Definition der Layout-Variablen
	<LinearLayout ...> 
		<Button 
			android:id="@+id/button" 
			...
			android:enabled="@{model.user.role == `admin`}" 
			android:text="@{model.buttonText}" // Data Binding (1-way)
			...
			android:onClick="@{() -> model.increaseClickCount()}" /> // Event Binding
		<EditText 
			android:id="@+id/input"
			...
			android:text="@={model.inputText}"/> // Data Binding (2-way)
	</LinearLayout> 
</layout>

protected void onCreate(Bundle savedInstanceState) { 
	super.onCreate(savedInstanceState); 
	ActivityMainBinding binding = DataBindingUtil.setContentView(...); 
	model = new MainModel();
	model.load(); 
	binding.setModel(model);
	// Binden der Layout-Daten auf effektive Daten
	// z.B. ViewModel mit Observables
}
\end{lstlisting}
\newpage

\subsection{Options-Menü}

\begin{itemize}
	\item Android-Apps können oben rechts ein Menü mit Optionen anbieten
	\item Erzeugung durch Aufruf \textit{Hook} in der Activity-Klasse:\\
	\texttt{onCreateOptionsMenu(Menu menu)}
	\begin{itemize}
		\item Hier kann ein Menü mit Einträgen bestückt werden
		\item \texttt{MenuInflater} + XML benutzen oder Java oder beides
	\end{itemize}
	\item Beim Klick auf Eintrag Aufruf eines anderen Hooks:\\
	\texttt{onOptionsItemSelected(MenuItem item)}
\end{itemize}
\noindent
Für ein Options-Menü muss eine .xml-Datei (Bsp. main\_menu.xml) im Ordner \texttt{res/menu} angelegt werden. Danach werden Informationen folgendermassen eingetragen:
\begin{figure}[htb!]
	\begin{subfigure}{0.5\textwidth}
		\centering
		\includegraphics[width=\linewidth]{img/menu_example.jpg}
		\caption{Menü und Items in XML definieren}
	\end{subfigure}
	\begin{subfigure}{0.5\textwidth}
		\centering
		\includegraphics[width=\linewidth]{img/menuinflater.jpg}
		\caption{Menü mit \texttt{MenuInflater} aufblasen}
	\end{subfigure}
\end{figure}

Um bspw. einen String in einem Menüpunkt einzufügen, gibt es drei verschiedene Möglichkeiten:
\begin{figure}[htb!]
	\centering
	\includegraphics[width=.8\textwidth]{img/menu_string.jpg}
	\caption{Möglichkeiten zum Einlesen eines Strings}
\end{figure}
\begin{figure}[htb!]
	\centering
	\includegraphics[width=.7\textwidth]{img/menu_selektierung.jpg}
	\caption{Event-Handling: Selektierung}
\end{figure}

\newpage

\subsection{Adapter-Views}
\emph{Behandelt wird hier nur das synchrone Laden von kleinen/schnellen Datenquellen, für asynchrones Laden von langsamen/grossen Datenquellen konsultiere Doku über \textbf{Loaders}.}
\begin{figure}[htb!]
	\centering
	\includegraphics[width=.8\textwidth]{img/adapter.png}
	\caption{Aufgabe des Adapters}
\end{figure}
\begin{itemize}
	\item Adapter $\rightarrow$ Verbindung zwischen Datenquelle und GUI
	\item Zapft \textit{Datenquelle} an und beliefert \textit{AdapterView}
	\item Erzeugt (Sub-)Views pro gefundenes Datenelement
	\item Transformiert Daten ggf. in benötigtes Zielformat
	\item Datenquellen:\\
	String-Array, String-Liste, Bilder, Datenbank, ...
\end{itemize}

\vspace{3em}

\begin{figure}[htb!]
	\centering
	\includegraphics[width=.8\textwidth]{img/adapter_string.png}
	\caption{Beispiel eines ArrayAdapter}
\end{figure}
\begin{itemize}
	\item Bindet irgend ein Array oder Liste mit beliebig getypeten Elementen an irgend eine AdapterView
	\item Für jedes Daten-Element wird eine SubView erzeugt
	\item \textbf{Default}: Erstellt \texttt{TextView} mit \texttt{element.toString()}-Wert
\end{itemize}
\begin{figure}[htb!]
	\centering
	\includegraphics[width=.8\textwidth]{img/adapterview_example.jpg}
	\caption{Beispiel einer AdapterView}
\end{figure}

\subsubsection{AdapterViews \& ListActivity}

\begin{itemize}
	\item \textbf{AdapterViews}: spezielle View-Klassen
		\begin{itemize}
			\item Sind für Zusammenarbeit mit Adaptern optimiert \\
			(Bsp.\texttt{ListView, GridView, Gallery, Spinner, Stack,...})
			\item Füllen Teile von sich mit von Adaptern erzeugten Views
			\item Leiten ab von \texttt{android.widget.AdapterView<T extends android.widget.Adapter>}
		\end{itemize}
	\item Spezielle Activity: \textbf{ListActivity}
		\begin{itemize}
			\item Vordefiniertes Layout (enthält eine \texttt{ListView}, kein XML nötig)
			\item Vordefinierte Callbacks (bei Auswahl einer List-Entry)
			\item Bietet Zugriff auf aktuelle Selektion / Datenposition
		\end{itemize}
\end{itemize}

\newpage

\subsubsection{android.widget.Spinner}

\begin{itemize}
	\item ComboBox oder DropDown-List genannt (weitere Alternative: AutoCompleteTextView)
	\item Zeigt ein ausgewähltes Element, bei Klick erscheint ein Auswahlmenü
	\item 2 Varianten, um Daten auf Spinner zu setzen:
		\begin{itemize}
			\item Im Code mit Adapter:\\
			\texttt{spinner.setAdapter(myAdapter)}
			\item Im XML mit Angabe einer String-Array-ID:\\
			\texttt{android:entries="@array/spinnerValues"}
		\end{itemize}
	\item Listener setzen für Behandlung der Auswahl:\\
	\texttt{spinner.setOnItemSelectedListener(...)}
\end{itemize}
\vspace{2em}
\begin{figure}[htb!]
	\centering
	\includegraphics[width=\textwidth]{img/spinner_demo.png}
	\caption{Übungs-Demo aus der Vorlesung SW02 - Spinner}
\end{figure}

\newpage

\subsubsection{android.widget.ListView}

\begin{itemize}
	\item Liste von Views/Items, die zur Auswahl stehen
	\item Braucht viel Platz! Meist wird ihr der ganze Bildschirm zugeteilt
	\item i.d.R. zusammen mit \texttt{ListActivity} verwendet, Verwendung:
		\begin{enumerate}
			\item Navigiere zu eigener ListActivity
			\item Auswahl $\rightarrow$ Resultat setzen $\rightarrow$ finish
			\item Auswertung des Rückgabewert im Caller
		\end{enumerate}
	\item Konzeptionell identisch zum Spinner, jedoch andere Darstellung auf UI
		\begin{itemize}
			\item Verwendungsentscheid:
			\begin{itemize}
				\item Kurze Liste $\rightarrow$ Spinner
				\item (Sehr) lange Listen $\rightarrow$ ListView / ListActivity
				\item Kennt der User die möglichen Auswahlwerte $\rightarrow$ AutoCompleteTextView
			\end{itemize}
			\item Adapter- / Datendefinition grundsätzlich bei beiden gleich\\
			(d.h. im Code oder durch XML-Array)
			\item Auswahlmodus: \texttt{setChoiceMode(ListView.CHOICE\_MODE\_*} \\
			$\rightarrow$ Single- / Multiselection
		\end{itemize}
\end{itemize}

\subsubsection{android.app.ListActivity}

\begin{itemize}
	\item Spezielle Activity zur Darstellung einer ListView
	\item Vordefiniertes Layout (full-screen Liste)
		\begin{itemize}
			\item \texttt{setContentView(...)} muss nicht aufgerufen werden
			\item Aufruf i.d.R. mit \texttt{startActivityForResult(...)}
			\item Vordefinierte vererbte Konfigurationsmethoden
				\begin{itemize}
					\item \texttt{setListAdapter(adapter)} setzt Daten für die Liste
					\item \texttt{getListView()} erlaubt Zugriff auf ListView-Instanz\\
					\textit{(anstelle von findViewById(..) + Casten)}
				\end{itemize}
		\end{itemize}
	\item Callback bei der Auswahl
		\begin{itemize}
			\item \texttt{onListItemClick(parentView, view, position, id)}\\
			Wird bei Auswahl aufgerufen (muss in Subklasse überschrieben werden, keine Listener-Registrierung nötig)
		\end{itemize}
\end{itemize}

\begin{figure}[htb!]
	\centering
	\includegraphics[width=.8\linewidth]{img/listview_demo.png}
	\caption{Übungs-Demo aus der Vorlesung SW02 - ListView / ListActivity}
\end{figure}

\newpage

\subsection{ViewModel - Konfigurationswechsel \& temporäre Datenspeicherung}

Bei jedem Konfigurationswechsel (z.B. Änderung Bildschirmorientation) wird die aktuelle Activity-Instanz zerstört und neu aufgebaut. Dabei besteht das Problem des \textbf{Zustandsverlusts}. Der Zustand alles Views mit einer ID (mit einigen Ausnahmen) wird automatisch gesichert und wiederhergestellt. Der \textbf{inhärente Zustand}, alles was nicht sichtbar und in Feldern gespeichert ist, geht jedoch verloren. Um entgegenzuwirken, kann ein \textbf{ViewModel} verwendet werden.

\begin{figure}[htb!]
	\centering
	\includegraphics[width=.6\textwidth]{img/viewmodel}
	\caption{Position des ViewModels in der temp. Datenspeicherung}
\end{figure}

\begin{itemize}
	\item Kapselt UI-Daten so, dass diese bei einer Konfigurationsänderung einer Activity in-memory erhalten bleiben \textit{(Für den Fall eines App-Kills müssen Daten immer noch persistiert werden)}
	\item Lebensdauer mit der Activity gekoppelt
	\item Weniger Aufwand für Behandlung von Konfigurationsänderungen
\end{itemize}

\begin{figure}[htb!]
	\centering
	\includegraphics[width=\textwidth]{img/viewmodel_demo.png}
	\caption{Übungs-Demo aus der Vorlesung SW02 - ViewModel}
\end{figure}

\newpage

\subsection{Rückmeldungen an den Benutzer}

\subsubsection{Toast}

\begin{itemize}
	\item Kurze Rückmeldung (Popup) an den Benutzer, keine Interaktion möglich, verschwindet nach gewisser Zeit.
	\item Konfiguration: Text, Layout, Anzeigezeit (kurz/lang), Ort (gravity)
	\item Toasts mit eigenem Layout werden mit CustomToastView erstellt
\end{itemize}
\vspace{1em}
Beispielcode zur Erstellung von Toasts:

\begin{lstlisting}
// Default-Toast: Einzeiler
Toast.makeToast(getApplicationContext(), "Das ist..", Toast.LENGTH_LONG).show()
																						// LENGTH: Nur LONG oder SHORT
							// Kontext: meistens "this"
							
// Toast mit anderem Anzeigeort:
Context context = getApplicationContext();
Toast toast = Toast.makeText(context, "Toast links oben!", Toast.LENGTH_LONG);
toast.setGravity(Gravity.TOP|Gravity.START,0,0); // (x,y) Offset
toast.show()
\end{lstlisting}

\subsubsection{Alert-Dialog}

\begin{figure}[htb!]
	\centering
	\includegraphics[width=.35\textwidth]{img/alert_dialog.jpg}
	\caption{Beispiel eines Alert-Dialogs}
\end{figure}

\begin{itemize}
	\item Fenster mit Interaktionsmöglichkeiten für den Benutzer
		\begin{itemize}
			\item Information / Eingabe von Daten
			\item Interaktion möglich
			\item Buttons: positive, neutral, negative
		\end{itemize}
	\item Vorteile
	\begin{itemize}
		\item Kaum Einschränken in punkto Darstellung
		\item Vorbereitet für die Anzeige von Daten
		\item Verschwindet erst, wenn sie vom Benutzer quittiert wurde
	\end{itemize}
	\item Konfiguration: Buttons, Titel, Icon, Nachricht\\
	Inhalt: Liste von Items oder eigene View
\end{itemize}

\newpage

\begin{itemize}
	\item Vorgehen beim Erstellen eines Alert-Dialog mit Builder-Muster
	\begin{enumerate}
		\item Builder erstellen: \texttt{new AlertBuilder.Builder(this)}
		\item Builder konfigurieren: \\
		\texttt{setXXX} + Registrierung von \texttt{ClickListeners}
		\item Dialog erstellen: \texttt{Dialog dialog = builder.create()}
		\item Dialog anzeigen: \texttt{dialog.show()}
	\end{enumerate}
	\item Anzeige von Dialogen ist \textbf{immer asynchron!}\\
	Bei \texttt{show()} wird nicht gewartet, kein Rückgabewert\\
	$\rightarrow$ Behandlung von Benutzerselektion mit Listener
\end{itemize}

\begin{figure}[htb!]
	\centering
	\includegraphics[width=.9\textwidth]{img/alertdialog.jpg}
	\caption{Beispiel eines AlertDialog aus Vorlesung}
\end{figure}

\newpage

\begin{figure}[htb!]
	\centering
	\includegraphics[width=\textwidth]{img/alertdialog_daten.png}
	\caption{Beispiel mit Auswahl-Daten}
\end{figure}
\begin{figure}[htb!]
	\centering
	\includegraphics[width=\textwidth]{img/alertdialog_custom.png}
	\caption{Beispiel mit eigenem Layout}
\end{figure}

\newpage
\noindent
Ein (offener) Dialog gehört zum Zustand einer Activity, ist ein Dialog noch geöffnet bei einem Konfigurationswechsel, dann wird dieser nicht gespeichert und auch nicht wiederhergestellt! Deshalb sollten Dialoge als \texttt{DialogFragment} implementiert werden. Der Zustand des Dialogs wird dann vom \texttt{FragmentManager} korrekt mit Lifecycle und Activity synchronisiert (save/restore)\\
Für den Moment: Ein \textbf{Fragment} ist ein wiederverwendbarer "UI Schnippsel" mit eigenem Zustand und Lifecycle.

\subsubsection{Notifications (Status-Bar)}

\begin{itemize}
	\item Persistente Nachricht
	\begin{itemize}
		\item Kurze Ticker-Nachricht in der Status-Bar
		\item Danach persistente Anzeige im Notification Window
		\item Bei Auswahl erfolgt Aufruf einer definierten Activity
	\end{itemize}
	\item Vorteile:\\
	Nachricht bleibt erhalten bis vom Nutzer quittiert\\
	Beliebig komplexe Behandlung, da Start einer Activity
	\item Nachteil:\\
	Etwas komplexere Mechanik wegen \texttt{PendingIntent}
\end{itemize}

\begin{figure}[htb!]
	\centering
	\includegraphics[width=\textwidth]{img/notification_demo.png}
	\caption{Übungs-Demo aus der Vorlesung SW02 - Notification}
\end{figure}

\newpage
\section{Android 3 - Persistenz \& Content Providers}

Persistenz: Daten über Laufzeit der App erhalten.
Für lokale Persistenz gibt es drei Möglichkeiten:
\begin{itemize}
	\item \textbf{Shared Preferences}\\
	Key/Value-Paare, Verwendung für kleine Datenmengen
	\item \textbf{Dateisystem}\\
	intern oder extern, in App-Sandbox (privat) oder auf SD-Karte (öffentlich), Verwendung für binäre/grosse Dateien, Export
	\item \textbf{Datenbank (Room)}\\
	SQLite + Object Relational Mapper (ORM), Verwendung für strukturierte Daten + Abfragen/Suche
\end{itemize}

\subsection{(Shared) Preferences}
\begin{itemize}
	\item Jede Activity hat ein SharedPreferences-Profil, persistente Einstellungen für Activity oder Applikation
	\item Key-Value-Store (persistente Map)
	\item Preferences für \textbf{Activity}: \\
	\texttt{Activity.getPreferences(mode)}\\
	Anwendungsfall: Activity-State persistent speichern
	\item Preferences für \textbf{Applikation}: \\
	\texttt{PreferenceManager.getDefaultSharedPreferences(ctx)}\\
	\texttt{Context.getSharedPreferences(name, mode)}
	\item Mögliche Datentypen für Preferences-Werte:\\
	\textit{String, int, float, long, boolean, Set<String>} (mit seperaten Werten)
\end{itemize}
\paragraph{Lesen und Schreiben auf Preferences}
\begin{itemize}
	\item Mehrere Dateien pro Applikation möglich, Zugriff mit\\
		\texttt{Activity.getSharedPreferences(name, mode)} (unterschiedliche Dateinamen)
	\item Lesen mit Methoden \texttt{SharedPreferences.get\textbf{X}()}\\
		\textbf{X} steht für den Typ, also String, Int, Boolean, ...
	\item 
\end{itemize}

	% TODO
	
\subsection{Dateisystem}

\begin{itemize}
	\item \textbf{Einsatzbereiche}
		\begin{itemize}
			\item Speichern/Laden von binären Dateien (Bilder, Musik, Video, Java-Objects, etc.)
			\item Caching (Heruntergeladene Dateien)
			\item Grosse Text-Dateien(Plain Text, Strukturierte Daten wie XML, JSON,))
		\end{itemize}
	\item Teilen / Freigeben von erstelltem Inhalt (Externer Speicher wie SD-Karte)
\end{itemize}


	% TODO
	
\subsubsection{Exkurs: Permission-Model}

	% TODO
	
\subsection{Datenbank (Room)}

Android-DB \textbf{SQLite} ist bei Android fix integriert. Room ist ein Object Relational Mapper (ORM) für Android







\end{document}